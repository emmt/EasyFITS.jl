var documenterSearchIndex = {"docs":
[{"location":"tables/#FITS-Table-extensions","page":"FITS Table extensions","title":"FITS Table extensions","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"In a given table column, cells may contain more than a single value.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"note: Note\nThe elements of a column of a FITS table extension are stored in the same memory order as in a Julia array. As a result, the rows of a column in a FITS table extension correspond to the last index in the equivalent Julia array. Method permutedims can be used is this convention does not suit you.","category":"page"},{"location":"tables/#Reading-a-single-table-column","page":"FITS Table extensions","title":"Reading a single table column","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To read a single column in a FITS table extension as an array arr, call read as:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"arr = read(hdu, col)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"with hdu the Header Data Unit containing the table and col the column name or number. The names of the columns are given by hdu.column_names and valid column numbers are in the range hdu.columns (see Table HDU Properties for a list of all properties). If col is a string or a symbol, keyword case can be used to specify whether uppercase/lowercase matters (case is false by default).","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"By default, all rows are read but it is possible to specify which rows to read:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"arr = read(hdu, col, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where rows can be an integer to read a single row, a unit range of integers to read these rows, or a colon : to read all the rows (the default). Properties hdu.first_row and hdu.last_row can be used to retrieve the first and last row numbers of hdu.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The read method automatically guess the number of dimensions and the type of the elements of the Julia array representing the column of a table. To improve type stability, the read method takes an optional first argument to specify the type of the result, from the least specific Array to Array{T} or Array{T,N}. For instance:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"arr = read(Vector{Float32}, hdu, col)\narr = read(Vector{Float32}, hdu, col, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"are both guaranteed to yield an instance of Vector{Float32} (an exception is thrown if the elements of the column cannot be converted to the given type or if the column cells are not scalar numbers).","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"In fact, the calls read(hdu,col) and read(hdu,col,rows) are respectively equivalent to read(Array,hdu,col) and read(Array,hdu,col,rows).","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The read! method can be called to overwrite the contents of an existing array (it must have contiguous entries) with the cells of a column:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"read!(arr, hdu, col)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where keyword first may be used to specify the first row to read (the first one, hdu.first_row, by default), the number of rows to read being deduced from the size of arr. Other keywords are anynull and null to deal with undefined values.","category":"page"},{"location":"tables/#Reading-several-table-columns","page":"FITS Table extensions","title":"Reading several table columns","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"In the most simple form, reading several table columns is done by one of:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(hdu, cols)\ndict = read(hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where, as for reading a single column, hdu is the Header Data Unit containing the table and rows may be specified to select the rows to read but cols is a vector or a tuple of column names/numbers, or a colon : to read all columns. Specify keyword case=true if columns are specified by their (symbolic) names and the case of these names matters.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The result of reading several columns is a dictionary whose keys are the names of the columns and whose values are the cells of the columns. The keys of the dictionary are the names of the table columns unconverted if keyword case=true and converted to upper-case letters otherwise. If this is not suitable, use the keyword rename to specify a function to modify the names of the columns. For example, with rename=identity the names of the columns will be left unchanged whatever the keyword case while with rename=lowercase the names of the columns will be converted to lower-case letters.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"In order to retrieve the units of the columns, specify keyword units=String and get a dictionary whose values are 2-tuples of the form (data,units) with data the column cells and units the column units as a string. The default behavior, that is to get a dictionary whose values are simply be the cells of the columns, corresponds to units=nothing.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To have a dictionary when cols is a single column name/number, just specify the type of the expected result as the leading argument. For example:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(Dict, hdu)\ndict = read(Dict, hdu, cols)\ndict = read(Dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Of course, this also works if the cols argument represents several columns without ambiguities.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The leading type argument may be more specific. For example:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(Dict{String,Array}, hdu, cols)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"is the same as with Dict, while:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(Dict{String,Vector}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"can only be successful if all read columns have 0-dimensional cells.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"If the leading argument is more specific than Dict, the units=String keyword is not allowed and retrieving the units is done by specifying that the values are tuples of an array and a string. For example:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(Dict{String,Tuple{Array,String}}, hdu, cols)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Using the leading type argument, it is also possible to retrieve a vector of the table columns (in the same order as specified in cols). For example:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"vect = read(Vector, hdu, cols)\nvect = read(Vector, hdu, cols, rows)\nvect = read(Vector{Array}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"It is also possible to retrieve the units at the same time:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"vect = read(Vector, hdu, cols; units=String)\nvect = read(Vector, hdu, cols, rows; units=String)\nvect = read(Vector{Tuple{Array,String}}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"With the read! method, the contents of an existing dictionary may be replaced by columns from a FITS table:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"read!(dict, hdu)\nread!(dict, hdu, cols)\nread!(dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where, as for the read method, keywords case and rename may be supplied. Call the merge! method instead to preserve pre-existing contents:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"merge!(dict, hdu)\nmerge!(dict, hdu, cols)\nmerge!(dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"With the push! method, a vector of columns can be augmented with additional columns:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"push!(vect, hdu)\npush!(vect, hdu, cols)\npush!(vect, hdu, cols, rows)","category":"page"},{"location":"tables/#Creating-a-table-extension","page":"FITS Table extensions","title":"Creating a table extension","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To create a new FITS table extension in the FITS file file, call:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"hdu = write(file, FitsTableHDU, cols)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"with cols defining the columns of the table. Each column definition is a pair name => format where name is the column name while format specifies the type of the column values and, optionally, their units and the size of the column cells. The following definitions are possible:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"name => type\nname => (type,)\nname => (type, units)\nname => (type, dims)\nname => (type, units, dims)\nname => (type, dims, units)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where type is either a Julia type (Number or String) or a letter (see table below), dims is an integer or a tuple of integers, and units is a string. By default, dims = (1,) and units = \"\".","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Type Letter Remarks\nAbstractString 'A' ASCII string\nBool 'L' \nInt8 'S' CFITSIO specific\nUInt8 'B' \nInt16 'I' \nUInt16 'U' CFITSIO specific\nInt32 'J' \nUInt32 'V' CFITSIO specific\nInt64 'K' \nUInt64 'W' CFITSIO specific\nFloat32 'E' \nFloat64 'D' \nComplex{Float32} 'C' \nComplex{Float64} 'M' \nFitsBit 'X' bits","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The returned object, hdu, can be used to add FITS keywords to the header of the table and, then, to write column data. Typically:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"hdu = write(file, FitsTableHDU, cols)\npush!(hdu, key1 => val1)         # add a first header keyword\npush!(hdu, key2 => (val2, com2)) # add a second header keyword with a comment\n...                              # add other header keywords\nwrite(hdu, col1 => arr1)         # write a first column\nwrite(hdu, col2 => arr2)         # write a second column\n...                              # write other columns","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where key1 => val1, key2 => (val2,com2), etc. specify header cards, while col1 => arr1, col2 => arr2, etc. specify columns names and associated data. Such a table may be created in a single call:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"write(file,\n      [key1 => val1, key2 => (val2, com2), ...],\n      [col1 => arr1, col2 => arr2, ...])","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"which follows the write(dest, header, data) convention in EasyFITS with dest the destination, header the header, and data the data.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The header may be specified in any forms accepted by the EasyFITS methods. Similarly, the columns may be specified in various forms as explained below.","category":"page"},{"location":"tables/#Writing-table-columns","page":"FITS Table extensions","title":"Writing table columns","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To write a single column into the FITS table extension hdu:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"write(hdu, col => arr, ...; first=hdu.first_row, case=false, null=nothing) -> hdu","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where col is the column name/number and arr is an array of column values. Column values are converted as needed and are written starting at the row specified by first. The leading dimensions of arr should be the same as those specified by the corresponding TDIMn keyword (with n the column number) and the remaining last dimension, if any, corresponds to the row index of the table.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"If col is a column name, keyword case may be used to indicate whether case of letters matters (default is false).","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Keyword null may be used to specify the value of undefined elements in arr.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Any number of columns may be specified as subsequent arguments. The same keywords apply to all columns.","category":"page"},{"location":"tables/#Table-HDU-Properties","page":"FITS Table extensions","title":"Table HDU Properties","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The following table lists all properties of a FITS table HDU.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Property Description\nnrows Number of rows\nrows Index range of rows\nfirst_row Index of first row\nlast_row Index of last row\nncols Number of columns\ncolumns Index range of columns\nfirst_column Index of first column\nlast_column Index of last column\ncolumn_name Column name accessor\ncolumn_names Column names\ncolumn_number Column number accessor\ncolumn_units Column units accessor\ndata_size Table dimensions\ndata_ndims Number of table dimensions\ndata_axes Indices along table dimensions\nextname Extension name\nhduname HDU name\nfile Associated FITS file\nnum HDU number\ntype HDU type: FITS_BINARY_TABLE_HDU\nxtension Extension: \"BINTABLE\" or \"TABLE\"","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To retrieve the units, the number, or the name of column col in the FITS table hdu object, use the properties column_units, column_number, or column_name properties as follows:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"hdu.column_units(col; case=false) -> units::String\nhdu.column_name(col; case=false) -> name::String\nhdu.column_number(col; case=false) -> number::Int","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Keyword case specifies whether the case of letters does matters when col is a (symbolic) name. The result of hdu.column_units(col) is always a string, possibly empty.","category":"page"},{"location":"library/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/#ltoh","page":"Reference","title":"ltoh","text":"","category":"section"},{"location":"library/#ntoh","page":"Reference","title":"ntoh","text":"","category":"section"},{"location":"library/#readchomp","page":"Reference","title":"readchomp","text":"","category":"section"},{"location":"library/#read!","page":"Reference","title":"read!","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"EasyFITS.Header\nEasyFITS.TableData\nFitsHDU\nFitsLogic","category":"page"},{"location":"library/#EasyFITS.Header","page":"Reference","title":"EasyFITS.Header","text":"EasyFITS.Header\n\nis the (union of) type(s) that are accepted to specify a FITS header in EasyFITS package.\n\nA header may be a vector of pairs like key => val, key => (val,com), or key => com with key the keyword name, val its value, and com its comment. The keyword name key is a string or a symbol which is automatically converted to uppercase letters and trailing spaces discarded. The syntax key => com, with com a string, is only allowed for commentary keywords COMMENT or HISTORY. For other keywords, the value is mandatory but the comment is optional, not specifying the comment is like specifying nothing for the comment; otherwise, the comment must be a string. The value val may be missing or undef to indicate that it is undefined. If the comment is too long, it is automatically split across multiple records for commentary keywords and it is truncated for other keywords. A non-commentary keyword may have units specified in square brackets at the beginning of the associated comment. Commentary keywords may appear more than once, other keywords are unique.\n\nFor example:\n\n[\"VERIFIED\" => true,\n \"COUNT\" => (42, \"Fundamental number\"),\n \"SPEED\" => (2.1, \"[km/s] Speed of gizmo\"),\n \"USER\" => \"Julia\",\n \"AGE\" => (undef, \"Some undefined value.\"),\n \"JOB\" => (missing, \"Another undefined value.\"),\n \"HISTORY\" => \"Some historical information.\",\n \"COMMENT\" => \"Some comment.\",\n \"COMMENT\" => \"Some other comment.\",\n \"HISTORY\" => \"Some other historical information.\"]\n\ndefines a possible FITS header with several records: a keyword VERIFIED having a logical value and no comments, a keyword COUNT having an integer value and a comment, a keyword SPEED having a floating-point value and a comment with units, a keyword USER having a string value, keywords AGE and JOB having comments but undefined values, and a few additional commentary keywords.\n\nA header may also be specified as a named tuple with entries key = val, key = (val,com), or key = com. The same rules apply as above except that key must be allowed as a variable symbolic name (no embedded hyphen '-').\n\nFinally, most methods assume that nothing can be used to indicate an empty header.\n\nnote: Note\nSpecifying a FITS header as a dictionary is purposely not implemented because, to a certain extend, the order of keywords in a FITS header is relevant and because some keywords (COMMENT, HISTORY, and CONTINUE) may appear more than once.\n\n\n\n\n\n","category":"type"},{"location":"library/#EasyFITS.TableData","page":"Reference","title":"EasyFITS.TableData","text":"EasyFITS.TableData\n\nis the union of types that can possibly be that of FITS table data. Instances of this kind are collections of key => vals or key => (vals, units) pairs with key the column name, vals the column values, and units the optional units of these values. Such collections can be dictionaries, named tuples, vectors, or tuples.\n\nFor table data specified by dictionaries or vectors, the names of the columns must all be of the same type.\n\nOwing to the variety of posibilities for representing column values with optional units, EasyFITS.TableData cannot be specific for the values of the pairs in the collection. The package therefore rely on error catcher methods to detect column with invalid associated data.\n\nAnother consequence is that there is a non-empty intersection between EasyFITS.TableData and EasyFITS.Header which imposes to rely on position of arguments to distinguish them.\n\n\n\n\n\n","category":"type"},{"location":"library/#EasyFITS.FitsHDU","page":"Reference","title":"EasyFITS.FitsHDU","text":"FitsHDU\n\nis the abstract type of FITS Header Data Units which consists in a header and a data parts. Concrete instances of FitsHDU behave as vectors whose elements are FITS header records, a.k.a. FITS cards, and which can be indexed by integers or by names.\n\nFor faster access to the records of a header, consider creating a FITS header object from a HDU object:\n\nhdr = FitsHeader(hdu::FitsHDU)\n\n\n\n\n\n","category":"type"},{"location":"library/#EasyFITS.FitsLogic","page":"Reference","title":"EasyFITS.FitsLogic","text":"FitsLogic()\n\nyields a singleton object used to indicate that FITS rules should be applied for some logical operation.  For example:\n\nisequal(FitsLogic(), s1, s2)\n\ncompares strings s1 and s2 according to FITS rules, that is case of letters and trailing spaces are irrelevant.\n\nisequal(FitsLogic(), x) -> f\n\nyields a predicate function f such that f(y) yields isequal(FitsLogic(),x,y).\n\n\n\n\n\n","category":"type"},{"location":"library/#FITS-Files","page":"Reference","title":"FITS Files","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"FitsFile\nopenfits\nopen(::Type{FitsFile}, ::AbstractString)\nopen(::Function, ::Type{FitsFile})\nreadfits\nreadfits!\nread(::Type{FitsFile}, ::AbstractString)\nwrite!\nwritefits\nwritefits!\nisopen(::FitsFile)\nclose(::FitsFile)\npathof(::FitsFile)\nfilemode(::FitsFile)\nisreadonly(::FitsFile)\niswritable(::FitsFile)\nseek(::FitsFile, ::Integer)\nseekstart(::FitsFile)\nseekend(::FitsFile)\nposition(::FitsFile)\nflush(::FitsFile)\neachmatch(::Any, ::FitsFile)","category":"page"},{"location":"library/#EasyFITS.FitsFile","page":"Reference","title":"EasyFITS.FitsFile","text":"FitsFile(filename, mode=\"r\"; extended=false) -> file\n\nopens FITS file filename for reading if mode is \"r\", for reading and writing if mode is \"r+\", or creates a new file if mode is \"w\" or \"w!\". File must not exists if mode is \"w\". File is overwritten if it exists and mode is \"w!\". The file is automatically closed when the file object is finalized so it is not necessary to call close(file).\n\nKeyword extended specifies whether to use extended file name syntax featured by the CFITSIO library.\n\n\n\n\n\n","category":"type"},{"location":"library/#EasyFITS.openfits","page":"Reference","title":"EasyFITS.openfits","text":"openfits(filename, mode=\"r\"; kwds...) -> file\n\nopens FITS file named filename with access mode. See FitsFile for the different modes and keywords.\n\n\n\n\n\nopenfits(filename, mode=\"r\"; kwds...) do file\n    ... # use file\nend\n\ndo-block syntax to open a FITS file which is automatically closed at the end of the block. See FitsFile for the different modes and keywords.\n\n\n\n\n\n","category":"function"},{"location":"library/#Base.open-Tuple{Type{FitsFile}, AbstractString}","page":"Reference","title":"Base.open","text":"open(FitsFile, filename, mode=\"r\"; kwds...) -> file\n\nopens FITS file named filename with access mode. See FitsFile and openfits for the different modes and keywords.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.open-Tuple{Function, Type{FitsFile}}","page":"Reference","title":"Base.open","text":"open(f::Function, args...; kwargs....)\n\nApply the function f to the result of open(args...; kwargs...) and close the resulting file descriptor upon completion.\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           write(io, \"Hello world!\")\n       end;\n\njulia> open(f->read(f, String), \"myfile.txt\")\n\"Hello world!\"\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\n","category":"method"},{"location":"library/#EasyFITS.readfits","page":"Reference","title":"EasyFITS.readfits","text":"readfits([R::Type,] filename, args...; ext=1, extended=false, kwds...) -> data\n\nreads some data in extension ext (a Header Data Unit number or a name) in FITS file filename. Specify keyword extended = true to use CFITSIO extended filename syntax.\n\nIf R is specified, the data is returned as an object of type R. Array type parameters may be specified in R. For example, specify R = Array{Float32} to ensure that the result be a single precision floating-point array.\n\nIf the extension is an image, args... specifies the ranges of pixels to read along the dimensions. The default is to read all pixels.\n\nIf the extension is a table, args... consist in up to 2 arguments cols and rows to select a subset of columns and of rows respectively. The default is to read all columns and rows.\n\n\n\n\n\n","category":"function"},{"location":"library/#EasyFITS.readfits!","page":"Reference","title":"EasyFITS.readfits!","text":"readfits!(dest, filename, args...; kwds...) -> dest\n\noverwrites destination dest with some data read from FITS file named filename. This is more efficient but is similar to:\n\ncopyto!(dest, readfits(typeof(dest), filename, args...; kwds...))\n\nSee readfits for the meaning of arguments and for possible keywords.\n\n\n\n\n\n","category":"function"},{"location":"library/#Base.read-Tuple{Type{FitsFile}, AbstractString}","page":"Reference","title":"Base.read","text":"read(io::IO, T)\n\nRead a single value of type T from io, in canonical binary representation.\n\nNote that Julia does not convert the endianness for you. Use ntoh or ltoh for this purpose.\n\nread(io::IO, String)\n\nRead the entirety of io, as a String (see also readchomp).\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization\"\n\n\n\n\n\nread([R::Type,] FitsFile, filename, args...; kwds...) -> data\n\nreads some data in FITS file filename. See readfits for the meaning of arguments and for possible keywords.\n\n\n\n\n\n","category":"method"},{"location":"library/#EasyFITS.write!","page":"Reference","title":"EasyFITS.write!","text":"write!(FitsFile, filename, args...; kwds...)\n\ncreates a new FITS file named filename whose contents is specified by args.... If the file already exists, it is (silently) overwritten. This method is equivalent to:\n\nwritefits(filename, args...; overwrite = true, kwds...)\n\nSee writefits for the meaning of args... and FitsFile for other keywords that may be specified when opening the file.\n\n\n\n\n\n","category":"function"},{"location":"library/#EasyFITS.writefits","page":"Reference","title":"EasyFITS.writefits","text":"writefits(filename, hdr, dat, args...; overwrite = false, kwds...)\n\ncreates a new FITS file named filename whose contents is specified by hdr, dat, and args.... If the file already exists, the method fails unless keyword overwrite is true. See FitsFile for other keywords that may be specified when opening the file.\n\nArguments hdr and dat are the header and the data of a 1st Header Data Unit (HDU) to write. Trailing arguments args... are headers and data of optional additional HDUs.\n\nSee also writefits! and FitsFile.\n\n\n\n\n\n","category":"function"},{"location":"library/#EasyFITS.writefits!","page":"Reference","title":"EasyFITS.writefits!","text":"writefits!(filename, args...; kwds...)\n\ncreates a new FITS file named filename whose contents is specified by args.... If the file already exists, it is (silently) overwritten. This method is equivalent to:\n\nwritefits(filename, args...; overwrite = true, kwds...)\n\nSee writefits for the meaning of args... and FitsFile for other keywords that may be specified when opening the file.\n\n\n\n\n\n","category":"function"},{"location":"library/#Base.isopen-Tuple{FitsFile}","page":"Reference","title":"Base.isopen","text":"isopen(file::FitsFile)\n\nreturns whether file is open.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.close-Tuple{FitsFile}","page":"Reference","title":"Base.close","text":"close(file::FitsFile)\n\ncloses the file associated with file.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.pathof-Tuple{FitsFile}","page":"Reference","title":"Base.pathof","text":"pathof(file::FitsFile) -> str\n\nyields the name of the FITS file associated with file.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.Filesystem.filemode-Tuple{FitsFile}","page":"Reference","title":"Base.Filesystem.filemode","text":"filemode(file::FitsFile)\n\nyields :r, :rw, or :w depending whether file is open for reading, reading and writing, or writing.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.isreadonly-Tuple{FitsFile}","page":"Reference","title":"Base.isreadonly","text":"isreadonly(file::FitsFile)\n\nreturns whether file is read-only.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.iswritable-Tuple{FitsFile}","page":"Reference","title":"Base.iswritable","text":"iswritable(file::FitsFile)\n\nreturns whether file is writable.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.seek-Tuple{FitsFile, Integer}","page":"Reference","title":"Base.seek","text":"seek(file::FitsFile, n) -> type\n\nmoves to n-th HDU of FITS file file and returns an integer identifying the type of the HDU:\n\nFITS_IMAGE_HDU if the n-th HDU contains an image.\nFITS_BINARY_TABLE_HDU if the n-th HDU contains a binary table.\nFITS_ASCII_TABLE_HDU if the n-th HDU contains an ASCII table.\nFITS_ANY_HDU if the n-th HDU is undefined.\n\nAn error is thrown if the file has been closed.\n\nSee also seekstart(::FitsFile), seekend(::FitsFile), and position(::FitsFile).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.seekstart-Tuple{FitsFile}","page":"Reference","title":"Base.seekstart","text":"seekstart(file::FitsFile) -> type\n\nmoves to the first HDU of FITS file file and returns an integer identifying the type of the HDU.\n\nSee also seek(::FitsFile).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.seekend-Tuple{FitsFile}","page":"Reference","title":"Base.seekend","text":"seekend(file::FitsFile) -> type\n\nmoves to the last HDU of FITS file file and returns an integer identifying the type of the HDU.\n\nSee also seek(::FitsFile).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.position-Tuple{FitsFile}","page":"Reference","title":"Base.position","text":"position(file::FitsFile) -> n\n\nyields the current HDU number of FITS file file. An error is thrown if the file has been closed.\n\nSee also seek(::FitsFile).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.flush-Tuple{FitsFile}","page":"Reference","title":"Base.flush","text":"flush(f::Union{FitsFile,FitsHDU})\n\nflushes the internal data buffers of f to the associated output FITS file.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.eachmatch-Tuple{Any, FitsFile}","page":"Reference","title":"Base.eachmatch","text":"eachmatch(pat, file::FitsFile)\n\nyields an iterator over the Header Data Units (HDUs) of FITS file matching pattern pat. Pattern pat can be a string or a regular expression to be matched against the name of the HDUs of file or a predicate function taking a HDU as argument and returning whether it matches.\n\nFor example:\n\nfor hdu in eachmatch(pat, file)\n    ... # do something\nend\n\nis a shortcut for:\n\ni = findfirst(pat, file)\nwhile i !== nothing\n    hdu = file[i]\n    ... # do something\n    i = findnext(pat, file, i+1)\nend\n\nwhile:\n\nfor hdu in reverse(eachmatch(pat, file))\n    ... # do something\nend\n\nis equivalent to:\n\ni = findlast(pat, file)\nwhile i !== nothing\n    hdu = file[i]\n    ... # do something\n    i = findprev(pat, file, i-1)\nend\n\n\n\n\n\n","category":"method"},{"location":"library/#FITS-Header-Data-Units-(HDUs)","page":"Reference","title":"FITS Header Data Units (HDUs)","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"nameof(::FitsHDU)\nEasyFITS.is_named","category":"page"},{"location":"library/#Base.nameof-Tuple{FitsHDU}","page":"Reference","title":"Base.nameof","text":"nameof(hdu::FitsHDU) -> str\n\nyields the name of the FITS header data unit hdu. The result is the value of the first keyword of \"EXTNAME\" or \"HDUNAME\" which exists and has a string value. If none of these keywords exist, the result is hdu.xtension which is the name of the FITS extension of hdu, that is \"IMAGE\", \"TABLE\", \"BINTABLE\", or \"ANY\" depending on whether hdu is an image, an ASCII table, a binary table, or anything else.\n\n\n\n\n\n","category":"method"},{"location":"library/#EasyFITS.is_named","page":"Reference","title":"EasyFITS.is_named","text":"EasyFITS.is_named(hdu, pat) -> bool\n\nyields whether pattern pat is equal to (in the FITS sense if pat is a string) or matches (if pat is a regular expression) the extension of the FITS header data unit hdu, or to the value of one of its \"EXTNAME\" or \"HDUNAME\" keywords. These are respectively given by hdu.xtension, hdu.extname, or hdu.hduname.\n\nThis method is used as a predicate for the search methods findfirst, findlast, findnext, and findprev.\n\nThe extension hdu.xtension is \"IMAGE\", \"TABLE\", \"BINTABLE\", or \"ANY\" depending on whether hdu is an image, an ASCII table, a binary table, or anything else.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Notes-for-developers","page":"Notes for developers","title":"Notes for developers","text":"","category":"section"},{"location":"devel/#The-FITS-standard","page":"Notes for developers","title":"The FITS standard","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The FITS format is described in the FITS Standard Document.","category":"page"},{"location":"devel/#The-CFITSIO-sub-module","page":"Notes for developers","title":"The CFITSIO sub-module","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS makes use of the Clang Julia package to automatically build file deps/deps.jl with constants, types, and low level functions to call the functions of the CFITSIO library with arguments of the correct type. All these are available in the EasyFITS.CFITSIO sub-module.","category":"page"},{"location":"devel/#Calls-to-functions-in-the-CFITSIO-library","page":"Notes for developers","title":"Calls to functions in the CFITSIO library","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"When calling functions of the CFITSIO library, there are several things to take care of:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Passing correct arguments. This is partially ensured by the type assertions in the @ccall macro. It is also necessary to check whether a pointer to some opaque structure in the library is valid.\nPreserving objects from being destroyed while being in use. Of course, this is automatically done by Julia for Julia objects, but must be handled for references or pointers to objects provided by the CFITSIO library.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"When an object obj is specified for an argument of type Ptr{T} to be passed to a C function, Julia ccall does something like:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"ref = Base.cconvert(Ptr{T}, obj)\nptr = Base.unsafe_convert(Ptr{T}, ref)\nresult = GC.@preserve ref call_some_c_function(..., ptr, ...)","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Here ref is an object (by default, Base.cconvert(Ptr{T},obj) yields obj itself) to be used with Base.unsafe_convert(Ptr{T},ref) to get the pointer and to be preserved from being garbage collected in order to warrant that the pointer remains valid.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Thanks to this mechanism, it is quite simple to ensure that valid pointers to opaque structures of the CFITSIO library be passed to a function of this library. For example, the code below is how is handled a pointer to a fitsfile C structure in our code:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"isnull(ptr::Ptr{T}) where {T} = ptr === Ptr{T}(0)\ncheck(ptr::Ptr) = isnull(ptr) ? error(\"invalid NULL pointer\") : ptr\nget_handle(file::FitsFile) = getfield(obj, :handle)\nget_file(hdu::AbstractHDU) = getfield(hdu, :file)\nBase.unsafe_convert(Ptr{CFITSIO.fitsfile}, obj::FitsFile) = check(get_handle(obj))\nBase.cconvert(Ptr{CFITSIO.fitsfile}, hdu::AbstractHDU) = get_file(hdu)","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Private methods isnull and check are introduced for readability. Private methods get_handle and get_file are two of the private accessors introduced to hide the fields of a FITS file object and let some other public properties be implemented. The former yields the pointer to the fitsfile C structure that is managed by a FitsFile object, while the latter yields the FitsFile object storing the HDU as it is the one that must be used and preserved when calling a C function requiring a pointer to a fitsfile C structure.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Note that FitsFile objects have a finalizer that automatically releases resources such as the associated fitsfile C structure when the object is garbage collected.","category":"page"},{"location":"devel/#Helper-functions","page":"Notes for developers","title":"Helper functions","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following non-exported functions are provided for meta-programming and for dealing with the types of arguments in calls to the functions of the CFITSIO library.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS.cfunc\nEasyFITS.ctype\nEasyFITS.cpointer","category":"page"},{"location":"devel/#EasyFITS.cfunc","page":"Notes for developers","title":"EasyFITS.cfunc","text":"EasyFITS.cfunc(pfx::Union{AbstractString,Symbol}, T::Type) -> sym\n\nyields the symbolic name of the function in the CFITSIO library whose prefix is pfx and whose suffix is deduced from the type T. Long/short function names are supported and automatically detected depending on whether pfx ends with an underscore character.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.ctype","page":"Notes for developers","title":"EasyFITS.ctype","text":"EasyFITS.ctype(T) -> T′\n\nyields the C type equivalent to T in CFITSIO library. This is mostly for Booleans which are treated as C char in the library, the other basic numerical types being unchanged. An error is thrown if the returned type has a different size than that of T. This is to make sure that Julia arrays with elements of type T can safely be used to store values of type T′.\n\nwarning: Warning\nThis only applies to element type of arrays. For boolean scalars, a Cint is the correct type.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.cpointer","page":"Notes for developers","title":"EasyFITS.cpointer","text":"EasyFITS.cpointer(arr::AbstractArray) -> ptr::Ptr{ctype(eltype(arr))}\n\nyields a pointer to the elements of array arr that can be used in calls to functions of the CFITSIO library. Compared to Ptr{Cvoid}(pointer(arr)), this function yields a typed pointer which prevents using arguments of the wrong type.\n\nwarning: Warning\nDo not forget to use GC.@protect arr ... to avoid arr being garbage collected while its address is in use.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Pixel-types","page":"Notes for developers","title":"Pixel types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists conventions used by CFITSIO for pixel types, that is the BITPIX keyword in FITS image extensions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type BITPIX\nBYTE_IMG UInt8 8\nSBYTE_IMG Int8 \nSHORT_IMG Int16 16\nUSHORT_IMG UInt16 \nLONG_IMG Int32 32\nULONG_IMG UInt32 \nLONGLONG_IMG Int64 64\nULONGLONG_IMG UInt64 \nFLOAT_IMG Float32 -32\nDOUBLE_IMG Float64 -64","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Types without a value in the BITPIX column are converted by the CFITSIO library into the other signed/unsigned type using special values of the BSCALE and BZERO keywords to allow for the reciprocal conversion. This is explicitly allowed by the FITS Standard (version 4.0).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS.type_to_bitpix\nEasyFITS.type_from_bitpix","category":"page"},{"location":"devel/#EasyFITS.type_to_bitpix","page":"Notes for developers","title":"EasyFITS.type_to_bitpix","text":"EasyFITS.type_to_bitpix(T)\n\nyields the code for FITS image pixels of type T. Argument can also be an array instance or type.\n\nBasic numeric types are recognized by this method which may be extended by other packages to yield the CFITSIO codes equivalent to their own types. The CFITSIO constants (to be prefixed by EasyFITS.CFITSIO.) and their corresponding Julia types and standard BITPIX code are:\n\nCFITSIO Constant Julia Type BITPIX\nBYTE_IMG UInt8 8\nSBYTE_IMG Int8 \nSHORT_IMG Int16 16\nUSHORT_IMG UInt16 \nLONG_IMG Int32 32\nULONG_IMG UInt32 \nLONGLONG_IMG Int64 64\nULONGLONG_IMG UInt64 \nFLOAT_IMG Float32 -32\nDOUBLE_IMG Float64 -64\n\nNote that CFITSIO can read/write non-standard pixel types (those without a BITPIX value above) by setting keywords BSCALE and BZERO with special values as explicitely allowed by the FITS Standard (version 4).\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_bitpix","page":"Notes for developers","title":"EasyFITS.type_from_bitpix","text":"EasyFITS.type_from_bitpix(b) -> T\n\nyields the Julia type T corresponding to FITS \"BITPIX\" b.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Array-data-types","page":"Notes for developers","title":"Array data types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists conventions used by CFITSIO for array element types.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code C Type Short Suffix Long Suffix\nTLOGICAL char l _log\nTBYTE unsigned char b _byt\nTSBYTE signed char sb _sbyt\nTUSHORT unsigned short ui _usht\nTSHORT short i _sht\nTUINT unsigned int uk _uint\nTINT int k _int\nTULONG unsigned long uj _ulng\nTLONG long j _lng\nTULONGLONG unsigned long long ujj _ulnglng\nTLONGLONG long long jj _lnglng\nTFLOAT float e _flt\nTDOUBLE double d _dbl\nTCOMPLEX float complex c _cmp\nTDBLCOMPLEX double complex m _dblcmp\nTSTRING char* s _str\nTBIT  x _bit\n  u _null","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Complex types float complex and double complex are stored as pairs of single/double precision floating-point values (this is not guaranteed by C99 standard so strict equivalence does not hold here).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS.type_to_code\nEasyFITS.type_from_code","category":"page"},{"location":"devel/#EasyFITS.type_to_code","page":"Notes for developers","title":"EasyFITS.type_to_code","text":"EasyFITS.type_to_code(T)\n\nyields the CFITSIO type code for a keyword value or table cells of type T. Argument can also be an array instance or type.\n\nBasic numeric types and string types are recognized by this method which may be extended by other packages to yield the CFITSIO codes equivalent to their own types. The CFITSIO type constants (to be prefixed by EasyFITS.CFITSIO.) and their corresponding C and Julia types are:\n\nCFITSIO Constant C Types Julia Types\nTLOGICAL char Cchar, Bool\nTBYTE unsigned char UInt8, Bool\nTSBYTE signed char Int8\nTUSHORT unsigned short Cushort\nTSHORT short Cshort\nTUINT unsigned int Cuint\nTINT int Cint\nTULONG unsigned long Culong\nTLONG long Clong\nTULONGLONG unsigned long long Culonglong\nTLONGLONG long long Clonglong\nTFLOAT float Cfloat\nTDOUBLE double Cdouble\nTCOMPLEX float complex Complex{Cfloat}\nTDBLCOMPLEX double complex Complex{Cdouble}\nTSTRING char* \nTBIT  \n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_code","page":"Notes for developers","title":"EasyFITS.type_from_code","text":"EasyFITS.type_from_code(c) -> T\n\nyields the Julia type T corresponding to CFITSIO type code c.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Column-data-types","page":"Notes for developers","title":"Column data types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists the correspondences between the TFORMn letter in FITS table extensions and the column data type.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type TFORM Description\nTLOGICAL Bool ’L’ Logical (1 byte)\nTBIT  ’X’ Bit (special)\nTBYTE UInt8 ’B’ 8-bit unsigned integer\nTSHORT Int16 ’I’ 16-bit signed integer\nTLONG Int32 ’J’ 32-bit signed integer\nTLONGLONG Int64 ’K’ 64-bit signed integer\nTSTRING String ’A’ Character (1 byte, used for strings)\nTFLOAT Float32 ’E’ 32-bit floating point\nTDOUBLE Float64 ’D’ 64-bit floating point\nTCOMPLEX ComplexF32 ’C’ 64-bit complex\nTDBLCOMPLEX ComplexF64 ’M’ 128-bit complex\n  ’P’ 32-bit array descriptor\n  ’Q’ 64-bit array descriptor","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"A few non-standard TFORM letters are allowed by CFITSIO. These are converted by the library into other types using TSCALE and TZERO keywords to allow for the reciprocal conversion following the same principles as for the BITPIX code and the BSCALE and BZERO keywords.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type TFORM Description\nTSBYTE Int8 ’S’ 8-bit signed integer\nTUSHORT UInt16 ’U’ 16-bit unsigned integer\nTULONG UInt32 ’V’ 32-bit unsigned integer\nTULONGLONG UInt64 ’W’ 64-bit unsigned integer","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The Type Code column indicates the code used by CFITSIO (it is not always consistent with the C types as defined in the above table, so my guess is that this code is only used to keep track of the column data type internally).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS.type_to_letter\nEasyFITS.type_from_letter","category":"page"},{"location":"devel/#EasyFITS.type_to_letter","page":"Notes for developers","title":"EasyFITS.type_to_letter","text":"EasyFITS.type_to_letter(T)\n\nyields the letter of the TFORMn keyword representing table cells of type T in FITS. Argument can also be an array instance or type.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_letter","page":"Notes for developers","title":"EasyFITS.type_from_letter","text":"EasyFITS.type_from_letter(c) -> T\n\nyields the Julia type T corresponding to CFITSIO column type letter c as assumed for the TFORMn keywords.\n\n\n\n\n\n","category":"function"},{"location":"images/#FITS-image-extensions","page":"FITS image extensions","title":"FITS image extensions","text":"","category":"section"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"FITS image extensions store multi-dimensional arrays with numerical values exactly as regular Julia arrays. In EasyFITS, a FITS image extension in an open file is represented by an object of type FitsImageDHU{T,N} with T the element type and N the number of dimensions.","category":"page"},{"location":"images/#Image-HDU-properties","page":"FITS image extensions","title":"Image HDU properties","text":"","category":"section"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"An image HDU has the following properties:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"Property Description\ndata_size Array dimensions\ndata_axes Array axes\ndata_ndims Number of dimensions N\ndata_eltype Element type T\nextname Extension name\nhduname HDU name\nfile Associated i/o FITS file\nnumber HDU number\ntype HDU type, i.e. FITS_IMAGE_HDU\nxtension Extension, i.e. \"IMAGE\"","category":"page"},{"location":"images/#Reading-a-FITS-image","page":"FITS image extensions","title":"Reading a FITS image","text":"","category":"section"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"To read the data stored by the Header Data Unit (HDU) object hdu of type FitsImageDHU HDU as an array arr, call read as:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(hdu)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"The result is of type Array{T,N} if hdu isa FitsImageDHU{T,N} holds. To choose another element type, say, S, just do:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(Array{S}, hdu)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"This is similar but more efficient than any of:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = S.(read(hdu))\narr = convert(Array{S}, read(hdu))","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"For type-stability, the expected number of dimension, say N, may also be specified. For example, any of:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(Array{Float32,2}, hdu)\narr = read(Matrix{Float32}, hdu)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"ensure that arr will be a 2-dimensional image with pixels of type Float32.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"Call read! to overwrite the elements of an existing array with the contents of the FITS image extension. For example:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"read!(arr, hdu)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"An hyper-rectangular sub-image can be read using the same syntax as for a Julia view by specifying indices and/or index ranges after the hdu argument. Index ranges may have non-unit steps but steps must all be positive. For example:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(hdu, :, :, 2)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"yields the 2nd slice in a 3-dimensional FITS image.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"The result is similar to:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(R, hdu)[:,:,2]","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"but should be more efficient as no array other than the result is allocated and fewer values are read.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"Call read! instead of read to overwrite the contents of an existing array. Following the previous example, reading the next slice could be done by:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"read!(arr, hdu, :, :, 3)","category":"page"},{"location":"images/#Creating-an-image-extension","page":"FITS image extensions","title":"Creating an image extension","text":"","category":"section"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"To create a new FITS image extension in an open FITS file","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"write(file::FitsFile, FitsImageHDU{T}, dims...=()) -> hdu\nwrite(file::FitsFile, FitsImageHDU, T::Type=UInt8, dims...=()) -> hdu\nwrite(file::FitsFile, FitsImageHDU, bitpix::Integer, dims=()) -> hdu","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"create a new primary array or image extension in FITS file file with a specified pixel type T and size dims.... If the FITS file is currently empty then a primary array is created, otherwise a new image extension is appended to the file. Pixel type can be specified as a numeric type T or as an integer BITPIX code bitpix.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"An object to manage the new extension is returned which can be used to push header cards and then to write the data.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"For example:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"hdu = write(file, FitsImageHDU, eltype(arr), size(arr))\nhdu[\"KEY1\"] = val1             # add a 1st header record\nhdu[\"KEY2\"] = (val2, str2)     # add a 2nd header record\nhdu[\"KEY3\"] = (nothing, str3)  # add a 3rd header record\nwrite(hdu, arr)                # write data","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"will create a new Header Data Unit (HDU) storing array arr with 3 additional header records: one named \"KEY1\" with value val1 and no comments, another named \"KEY2\" with value val2 and comment string str2, and yet another one named \"KEY3\" with no value and with comment string str3. Note that special names \"COMMENT\", \"HISTORY\", and \"\" indicating commentary entries have no associated, only a comment string, say str which can be specified as str or as (nothing,str).","category":"page"},{"location":"files/#Access-to-FITS-files","page":"Access to FITS files","title":"Access to FITS files","text":"","category":"section"},{"location":"files/#Direct-reading-of-data","page":"Access to FITS files","title":"Direct reading of data","text":"","category":"section"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"The simplest way to read some data in a FITS file is to call readfits:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"data = readfits(filename, args...; kwds...)","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"with filename the name of the file.","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"By default, the data of the first FITS extension in filename is read. Keyword ext may however be set with a number, a name, or a symbol to select another extension. Another possibility is to specify the keyword extended = true to open the file using the extended file name syntax implemented by the CFITSIO library.","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"The default is to read all the data part of the selected FITS extension but optional arguments args... and keywords kwds... may be specified to restrict the read contents:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"If the FITS extension is an image, args... specifies the ranges of pixels to read along the dimensions. For example:\ndata = readfits(filename, :, :, 5)\nwould read the 5th slice in a 3-dimensional image. This is equivalent but more efficient than:\ndata = readfits(filename)[:, :, 5]\nwhich amounts to reading all the data and then only keep the 5th slice.\nIf the FITS extension is a table, args... may be up to 2 arguments, cols and rows, to respectively select a subset of columns and rows. For example:\nA = readfits(filename, (\"Speed\", \"Height\"))\nB = readfits(filename, :, 11:40)\nrespectively yield the columns named Speed and Height of the table and all the columns of the table but only for rows in the range 11:40. Keyword case may be used to indicate whether letter case does matter in the column names. Note that, in EasyFITS the rows of a table correspond to the last dimension of arrays. This is to have the same storage order in memory and in the FITS file. Method permutedims can be used is this convention does not suit you.","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"The type of the object returned by readfits depends on the kind of the FITS extension and may also depend on the optional arguments args... and on the keywords kwds...:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"If the FITS extension is an image, the data is read as a Julia Array.\nIf the FITS extension is a table, then, if cols is a single column name or number, an array of the columns values is returned, otherwise, a dictionary indexed by the column names is returned. Note that, a column range like 4:4 would yield a dictionary with a single column (the 4th one) in that context. Keywords case and rename are available to indicate how to search the columns by name in the table and how to translate these names into dictionary keys.","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"To avoid ambiguities or for improved type-stability, a leading type argument can be specified in readfits to indicate the expected type for the returned data:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"data = readfits(R::Type, filename, args...; kwds...)::R","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"Array type parameters such as element type and number of dimensions may be specified in R. For example:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"data = readfits(Array{Float32,3}, filename)","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"ensures that the result be a single precision floating-point 3-dimensional array; while:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"data = readfits(Dict, filename, cols; ext=2)","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"ensures that the table in 2nd FITS Header Data Unit is returned as a dictionary even though cols specifies a single column.","category":"page"},{"location":"files/#Direct-writing-of-data","page":"Access to FITS files","title":"Direct writing of data","text":"","category":"section"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"In principle, directly writing data in a FITS file is as simple as direct reading of data.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The EasyFITS package provides an interface for reading/writing FITS files (widely used in Astronomy) in Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code is on GitHub.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"files.md\", \"hdus.md\", \"headers.md\", \"images.md\",\n         \"tables.md\", \"install.md\", \"grammar.md\", \"library.md\"]","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"grammar/#The-*Grammar*-of-EasyFITS","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"","category":"section"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"FITS file may have quite complex structure and EasyFITS implement a grammar that is intended to make clear the intention when reading the code and to help to guess the correct syntax when writing code. Most of the assumed rules should be familiar to Julia users.","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"The general syntax to read some data in a FITS file follows the following pattern:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"data = read([type,] src[, what...])","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"where:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"type is an optional Julia type to specify the expected type of the result.\nsrc is the source to read: a filename name, a FitsFile object representing an open FITS file, or a FitsHDU object representing a FITS Header Data Unit in an open FITS file.\nwhat... denotes optional arguments to specify which part(s) to read: index ranges of an array if reading a FITS image extension, column(s) and rows if reading a FITS table extension.","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"Overwriting the contents of an existing destination object dest may be done by:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"read!(dest, src, what...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"or by:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"merge!(dest, src, what...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"when the intention is to preserve (part of) the contents of dest, or also by:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"push!(dest, src, what...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"to append the read data to the contents of dest.","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"Create a new HDU in file:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"hdu = write(file, hdutype, defs...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"Write some data in a FITS file:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"write(file, header, data) -> file","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"which yields file so that chaining calls is possible to write several HDUs in a row:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"write(write(write(file, header1, data1), header2, data2), header3, data3)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"which is equivalent to the more readable form:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"write(file, header1, data1, header2, data2, header3, data3)","category":"page"}]
}
