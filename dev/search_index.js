var documenterSearchIndex = {"docs":
[{"location":"writing/#Writing-FITS-files","page":"Writing FITS files","title":"Writing FITS files","text":"","category":"section"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"This section explains how to directly write a FITS file in a single function call whose arguments readily reflects the structure of the FITS file or how to create and write the contents of a FITS file piece-by-piece.","category":"page"},{"location":"writing/#Direct-writing-of-a-FITS-file","page":"Writing FITS files","title":"Direct writing of a FITS file","text":"","category":"section"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"A complex (i.e. with multiple HDUs) FITS file may be directly written in a single call to writefits or writefits! as:","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"writefits(filename, hdr1, dat1, hdr2, dat2, ...; kwds...)","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"where filename is the name of the FITS file, hdr1 and dat1 specify the header and data parts of the first HDU, hdr2 and dat2 specify the header and data parts of the second HDU and so on. Here kwds... represent keywords that are passed to FitsFile. The call writefits!(args...; kwds...) is a shortcut for writefits(args...; overwrite = true, kwds...) which overwrites filename if it already exists.","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"In EasyFITS, there are many different possible ways to specify a HDU header and data:","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"A header may be nothing if there are no additional keywords other than the structural keywords describing the data part. Otherwise, the possible types for a header are given by the union EasyFITS.Header: a header may be a collection of FitsCard instances (i.e. an instance of FitsHeader, a tuple, or a vector of FITS cards), a named tuple, a tuple or a vector of pairs like key => val or key => (val, com) with key the keyword name, val its value, and com a comment.\nFor a FITS Image HDU, the data part is specified as a numerical Julia array.\nFor a FITS Table HDU, the data part may be specified by a dictionary (whose keys are the column names and whose values are the corresponding column data), a vector of column data, a named tuple, a tuple or a vector of pairs like col => val with col the column name and val the column data. The data of each column of a table is a Julia array, the number of rows of the table is the last dimension of these arrays which must be the same for all columns.","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"Calling writefits or writefits!, the structure of the resulting FITS file can be made obvious by the code as in the following complex example with array arr saved in the primary HDU and two tables in the next HDUs:","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"using Dates, EasyFITS\nfilename = \"/tmp/test.fits\";\narr = rand(Float32, (3,4,5));\nnrows = 20;\ninds = 1:nrows;\nspeed = rand(Float64, nrows);\nmass = rand(Float32, nrows);\nposition = rand(Float32, 3, nrows);\nphase = (1:7) .// 3;\namplitude = exp.(-1:-1:-7);\nx = amplitude.*cos.(phase);\ny = amplitude.*sin.(phase);\nwritefits(filename,\n          #-----------------------------------------------------------------\n          # First HDU must be a FITS \"image\", but data may be empty.\n          #\n          # Header part as a vector of `key=>val` or `key=>(val,com)` pairs:\n          [\"DATE\"    => (now(), \"date of creation\"),\n           \"HISTORY\" => \"This file has been produced by EasyFITS\",\n           \"USER\"    => ENV[\"USER\"]],\n          # Data part as an array:\n          arr,\n          #-----------------------------------------------------------------\n          # Second HDU, here a FITS \"table\".\n          #\n          # Header part of 2nd HDU as a tuple of pairs:\n          (\"EXTNAME\" => (\"MY-EXTENSION\", \"Name of this extension\"),\n           \"EXTVER\"  => (1, \"Version of this extension\")),\n          # Data part is a table in the form of a named tuple:\n          (Speed    = (speed, \"km/s\"),  # this column has units\n           Indices  = inds,             # not this one\n           Mass     = (mass, \"kg\"),\n           Position = (position, \"cm\")),\n          #-----------------------------------------------------------------\n          # Third HDU, another FITS \"table\".\n          #\n          # Header part of 3rd HDU as a named tuple (note that keywords must\n          # be in uppercase letters):\n          (EXTNAME = (\"MY-OTHER-EXTENSION\", \"Name of this other extension\"),\n           EXTVER  = (1, \"Version of this other extension\"),\n           COMMENT = \"This is an interesting comment\"),\n          # Data part is a table in the form of a vector of pairs (column names\n          # can be strings or symbols but not a mixture):\n          [:phase => ((180/Ï€).*phase, \"deg\"),\n           :amplitude => (amplitude, \"V\"),\n           :xy => (hcat(x,y)', \"V\")])","category":"page"},{"location":"writing/#Advanced-writing-of-a-FITS-file","page":"Writing FITS files","title":"Advanced writing of a FITS file","text":"","category":"section"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"Direct writing of a FITS file with writefits or writefits! is designed to write all the content of a FITS file in a single function call and with a syntax that readily shows the structure of the file. This is not suitable when not all content is immediately available or when it is more convenient to write the FITS file piece by piece. The latter is typically done by the following steps:","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"Create a new empty FITS file for writing with the FitsFile constructor.\nAppend a new HDU to with the FitsImageHDU constructor or the FitsTableHDU constructor.\nInstantiate the FITS keywords of the header part of the HDU.\nWrite the data part of the HDU. This may be done by chunks and this depend on whether the HDU is an image or a table.\nEventually close the FITS file with close. Closing the FITS file is automatically done when the object representing the file is no longer used and garbage collected, closing the file is therefore optional.","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"Remarks:","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"Steps 2 to 4 can be repeated as many times as necessary to create more than one HDU.","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"For example, with arr a Julia array to be written in the data part of the HDU:","category":"page"},{"location":"writing/","page":"Writing FITS files","title":"Writing FITS files","text":"# Create the file:\nfile = FitsFile(filename, \"w\")\n# Appends a new HDU to store array data `arr`:\nhdu = FitsImageHDU(file, arr)\n# Set some keywords in the header part of the HDU:\nhdu[\"HDUNAME\"] = (\"SOME_NAME\", \"Name of this HDU\")\nhdu[\"COMMENT\"] = \"Some comment.\"\n# Write the data part of the HDU:\nwrite(hdu, arr)\n# Close the file:\nclose(file)","category":"page"},{"location":"library/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"library/#EasyFITS.FitsHDU","page":"Reference","title":"EasyFITS.FitsHDU","text":"FitsHDU\n\nis the abstract type of FITS Header Data Units which consists in a header and a data parts. Concrete instances of FitsHDU behave as vectors whose elements are FITS header records, a.k.a. FITS cards, and which can be indexed by integers or by names.\n\nFor faster access to the records of a header, consider creating a FITS header object from a HDU object:\n\nhdr = FitsHeader(hdu::FitsHDU)\n\n\n\n\n\n","category":"type"},{"location":"library/#EasyFITS.FitsError","page":"Reference","title":"EasyFITS.FitsError","text":"FitsError <: Exception\n\nis the type of exceptions thrown when an error occurs in the FITSIO library used to manage FITS files.\n\n\n\n\n\n","category":"type"},{"location":"library/#EasyFITS.FitsLogic","page":"Reference","title":"EasyFITS.FitsLogic","text":"FitsLogic()\n\nyields a singleton object to indicate that FITS rules should be applied for some logical operation. For example:\n\nisequal(FitsLogic(), s1, s2)\n\ncompares strings s1 and s2 according to FITS rules, that is case of letters and trailing spaces are irrelevant.\n\nisequal(FitsLogic(), x) -> f\n\nyields a predicate function f such that f(y) yields isequal(FitsLogic(),x,y).\n\n\n\n\n\n","category":"type"},{"location":"library/#Aliases","page":"Reference","title":"Aliases","text":"","category":"section"},{"location":"library/#EasyFITS.Header","page":"Reference","title":"EasyFITS.Header","text":"EasyFITS.Header\n\nis the (union of) type(s) that are accepted to specify a FITS header in EasyFITS package.\n\nA header may be a vector of pairs like key => val, key => (val,com), or key => com with key the keyword name, val its value, and com its comment. The keyword name key is a string or a symbol which is automatically converted to uppercase letters and trailing spaces discarded. The syntax key => com, with com a string, is only allowed for commentary keywords COMMENT or HISTORY. For other keywords, the value is mandatory but the comment is optional, not specifying the comment is like specifying nothing for the comment; otherwise, the comment must be a string. The value val may be missing or undef to indicate that it is undefined. If the comment is too long, it is automatically split across multiple records for commentary keywords and it is truncated for other keywords. A non-commentary keyword may have units specified in square brackets at the beginning of the associated comment. Commentary keywords may appear more than once, other keywords are unique.\n\nFor example:\n\n[\"VERIFIED\" => true,\n \"COUNT\" => (42, \"Fundamental number\"),\n \"SPEED\" => (2.1, \"[km/s] Speed of gizmo\"),\n \"USER\" => \"Julia\",\n \"AGE\" => (undef, \"Some undefined value.\"),\n \"JOB\" => (missing, \"Another undefined value.\"),\n \"HISTORY\" => \"Some historical information.\",\n \"COMMENT\" => \"Some comment.\",\n \"COMMENT\" => \"Some other comment.\",\n \"HISTORY\" => \"Some other historical information.\"]\n\ndefines a possible FITS header with several records: a keyword VERIFIED having a logical value and no comments, a keyword COUNT having an integer value and a comment, a keyword SPEED having a floating-point value and a comment with units, a keyword USER having a string value, keywords AGE and JOB having comments but undefined values, and a few additional commentary keywords.\n\nA header may also be specified as a named tuple with entries key = val, key = (val,com), or key = com. The same rules apply as above except that key must be allowed as a variable symbolic name (no embedded hyphen '-').\n\nFinally, most methods assume that nothing can be used to indicate an empty header.\n\nnote: Note\nSpecifying a FITS header as a dictionary is purposely not implemented because, to a certain extend, the order of keywords in a FITS header is relevant and because some keywords (COMMENT, HISTORY, and CONTINUE) may appear more than once.\n\n\n\n\n\n","category":"type"},{"location":"library/#EasyFITS.TableData","page":"Reference","title":"EasyFITS.TableData","text":"EasyFITS.TableData\n\nis the union of types that can possibly be that of FITS table data. Instances of this kind are collections of key => vals or key => (vals, units) pairs with key the column name, vals the column values, and units the optional units of these values. Such collections can be dictionaries, named tuples, vectors, or tuples.\n\nFor table data specified by dictionaries or vectors, the names of the columns must all be of the same type.\n\nOwing to the variety of possibilities for representing column values with optional units, EasyFITS.TableData cannot be specific for the values of the pairs in the collection. The package therefore rely on error catcher methods to detect column with invalid associated data.\n\nAnother consequence is that there is a non-empty intersection between EasyFITS.TableData and EasyFITS.Header which imposes to rely on position of arguments to distinguish them.\n\n\n\n\n\n","category":"type"},{"location":"library/#Direct-reading/writing-of-FITS-files","page":"Reference","title":"Direct reading/writing of FITS files","text":"","category":"section"},{"location":"library/#EasyFITS.readfits","page":"Reference","title":"EasyFITS.readfits","text":"readfits(FitsHeader, filename; ext=1, kwds...) -> hdr::FitsHeader\nread(FitsHeader, filename; ext=1, kwds...) -> hdr::FitsHeader\nread(filename, FitsHeader; ext=1, kwds...) -> hdr::FitsHeader\n\nRead the header of the ext extension of the FITS file filename. See FitsFile for the possible keywords kwds....\n\n\n\n\n\nreadfits([R::Type,] filename, args...; ext=1, extended=false, kwds...) -> data\n\nreads some data in extension ext (a Header Data Unit number or a name) in FITS file filename. Specify keyword extended = true to use CFITSIO extended filename syntax.\n\nIf R is specified, the data is returned as an object of type R. Array type parameters may be specified in R. For example, specify R = Array{Float32} to ensure that the result be a single precision floating-point array.\n\nIf the extension is an image, args... specifies the ranges of pixels to read along the dimensions. The default is to read all pixels.\n\nIf the extension is a table, args... consist in up to 2 arguments cols and rows to select a subset of columns and of rows respectively. The default is to read all columns and rows.\n\n\n\n\n\n","category":"function"},{"location":"library/#EasyFITS.readfits!","page":"Reference","title":"EasyFITS.readfits!","text":"readfits!(dest, filename, args...; kwds...) -> dest\n\noverwrites destination dest with some data read from FITS file named filename. This is more efficient but is similar to:\n\ncopyto!(dest, readfits(typeof(dest), filename, args...; kwds...))\n\nSee readfits for the meaning of arguments and for possible keywords.\n\n\n\n\n\n","category":"function"},{"location":"library/#EasyFITS.writefits","page":"Reference","title":"EasyFITS.writefits","text":"writefits(filename, hdr, dat, args...; overwrite = false, kwds...)\n\ncreates a new FITS file named filename whose contents is specified by hdr, dat, and args.... If the file already exists, the method fails unless keyword overwrite is true. See FitsFile for other keywords that may be specified when opening the file.\n\nArguments hdr and dat are the header and the data of a 1st Header Data Unit (HDU) to write. Trailing arguments args... are headers and data of optional additional HDUs.\n\nSee also writefits! and FitsFile.\n\n\n\n\n\n","category":"function"},{"location":"library/#EasyFITS.writefits!","page":"Reference","title":"EasyFITS.writefits!","text":"writefits!(filename, args...; kwds...)\n\ncreates a new FITS file named filename whose contents is specified by args.... If the file already exists, it is (silently) overwritten. This method is equivalent to:\n\nwritefits(filename, args...; overwrite = true, kwds...)\n\nSee writefits for the meaning of args... and FitsFile for other keywords that may be specified when opening the file.\n\n\n\n\n\n","category":"function"},{"location":"library/#FITS-files","page":"Reference","title":"FITS files","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"Missing EasyFITS.write!, read(::FitsFile, ...), read!(::DenseArray{<:Number},::FitsImageHDU,::SubArrayIndex...) read!(::DenseArray{<:Number},::FitsImageHDU)","category":"page"},{"location":"library/#EasyFITS.FitsFile","page":"Reference","title":"EasyFITS.FitsFile","text":"file = FitsFile(filename, mode=\"r\"; extended=false)\n\nOpen FITS file filename for reading if mode is \"r\", for reading and writing if mode is \"rw\", or create a new file if mode is \"w\" or \"w!\".\n\nFile must not exists if mode is \"w\". File is overwritten if it exists and mode is \"w!\". The file is automatically closed when the file object is finalized, i.e.. no needs to call close(file).\n\nKeyword extended specifies whether to use extended file name syntax featured by the CFITSIO library.\n\n\n\n\n\nFitsFile(func::Function, filename, mode=\"r\"; kwds...)\n\nExecute func(file) with file the FITS file filename open for mode access and close file even though func may throw an exception. This is typically used with the do-block syntax:\n\nFitsFile(filename, mode=\"r\"; kwds...) do file\n    ... # use file\nend\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.pathof-Tuple{FitsFile}","page":"Reference","title":"Base.pathof","text":"pathof(file::FitsFile) -> filename\n\nReturn the name of the FITS file associated with file.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.Filesystem.filemode-Tuple{FitsFile}","page":"Reference","title":"Base.Filesystem.filemode","text":"filemode(file::FitsFile)\n\nReturn :r, :rw, or :w depending whether file is open for reading only, reading and writing, or writing.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.isreadonly-Tuple{FitsFile}","page":"Reference","title":"Base.isreadonly","text":"isreadonly(file::FitsFile)\n\nReturn whether file is read-only.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.iswritable-Tuple{FitsFile}","page":"Reference","title":"Base.iswritable","text":"iswritable(file::FitsFile)\n\nReturn whether file is writable.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.seek-Tuple{FitsFile, Integer}","page":"Reference","title":"Base.seek","text":"seek(file::FitsFile, n) -> type\n\nmoves to n-th HDU of FITS file file and returns an integer identifying the type of the HDU:\n\nFITS_IMAGE_HDU if the n-th HDU contains an image.\nFITS_BINARY_TABLE_HDU if the n-th HDU contains a binary table.\nFITS_ASCII_TABLE_HDU if the n-th HDU contains an ASCII table.\nFITS_ANY_HDU if the n-th HDU is undefined.\n\nAn error is thrown if the file has been closed.\n\nSee also seekstart(::FitsFile), seekend(::FitsFile), and position(::FitsFile).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.seekstart-Tuple{FitsFile}","page":"Reference","title":"Base.seekstart","text":"seekstart(file::FitsFile) -> type\n\nmoves to the first HDU of FITS file file and returns an integer identifying the type of the HDU.\n\nSee also seek(::FitsFile).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.seekend-Tuple{FitsFile}","page":"Reference","title":"Base.seekend","text":"seekend(file::FitsFile) -> type\n\nmoves to the last HDU of FITS file file and returns an integer identifying the type of the HDU.\n\nSee also seek(::FitsFile).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.position-Tuple{FitsFile}","page":"Reference","title":"Base.position","text":"position(file::FitsFile) -> n\n\nyields the current HDU number of FITS file file. An error is thrown if the file has been closed.\n\nSee also seek(::FitsFile).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.flush-Tuple{FitsFile}","page":"Reference","title":"Base.flush","text":"flush(f::Union{FitsFile,FitsHDU})\n\nflushes the internal data buffers of f to the associated output FITS file.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.eachmatch-Tuple{Any, FitsFile}","page":"Reference","title":"Base.eachmatch","text":"eachmatch(pat, file::FitsFile)\n\nyields an iterator over the Header Data Units (HDUs) of FITS file matching pattern pat. Pattern pat can be a string or a regular expression to be matched against the name of the HDUs of file or a predicate function taking a HDU as argument and returning whether it matches.\n\nFor example:\n\nfor hdu in eachmatch(pat, file)\n    ... # do something\nend\n\nis a shortcut for:\n\ni = findfirst(pat, file)\nwhile i !== nothing\n    hdu = file[i]\n    ... # do something\n    i = findnext(pat, file, i+1)\nend\n\nwhile:\n\nfor hdu in reverse(eachmatch(pat, file))\n    ... # do something\nend\n\nis equivalent to:\n\ni = findlast(pat, file)\nwhile i !== nothing\n    hdu = file[i]\n    ... # do something\n    i = findprev(pat, file, i-1)\nend\n\n\n\n\n\n","category":"method"},{"location":"library/#FITS-image-HDUs","page":"Reference","title":"FITS image HDUs","text":"","category":"section"},{"location":"library/#EasyFITS.FitsImageHDU","page":"Reference","title":"EasyFITS.FitsImageHDU","text":"hdu = FitsImageHDU(file::FitsFile, dims...; bitpix=...)\nhdu = FitsImageHDU{T}(file::FitsFile, dims...)\nhdu = FitsImageHDU{T,N}(file::FitsFile, dims...)\n\ncreate a new primary array or image extension in FITS file file with a specified pixel type T and size dims.... If the FITS file is currently empty then a primary array is created, otherwise a new image extension is appended to the file. Pixel type can be specified as a numeric type T or as an integer BITPIX code bitpix.\n\nAn object to manage the new extension is returned which can be used to push header cards and then to write the data.\n\nIf the array to be written is available, the element type and dimensions can be inferred from the array itself:\n\nhdu = FitsImageHDU{T=eltype(arr),N=ndims(arr)}(file::FitsFile, arr::AbstractArray)\n\nFor example:\n\nhdu = FitsImageHDU(file, arr)\nhdu[\"KEY1\"] = val1             # add a 1st header record\nhdu[\"KEY2\"] = (val2, str2)     # add a 2nd header record\nhdu[\"KEY3\"] = (nothing, str3)  # add a 3rd header record\nwrite(hdu, arr)                # write data\n\nwill create a new Header Data Unit (HDU) storing array arr with 3 additional header records: one named \"KEY1\" with value val1 and no comments, another named \"KEY2\" with value val2 and comment string str2, and yet another one named \"KEY3\" with no value and with comment string str3. Note that special names \"COMMENT\", \"HISTORY\", and \"\" indicating commentary entries have no associated, only a comment string, say str which can be specified as str or as (nothing,str).\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.read-Tuple{FitsImageHDU}","page":"Reference","title":"Base.read","text":"read(R::Type = Array, hdu::FitsImageHDU[, inds...]) -> arr::R\n\nreads the FITS image data in hdu or the rectangular sub-region defined by the indices inds... if specified.\n\nOptional argument R is to restrict the ouput type and improve type-stability. For example:\n\narr = convert(Array{Float32}, read(hdu))\narr = read(Array{Float32}, hdu)\narr = read(Array{Float32,3}, hdu)\n\nyield similar results if hdu is a 3-dimensional image extension but the 2nd example is more efficient than the 1st one as no temporary array is needed if the pixel type is not equivalent to Float32 and the 3rd example is completely type-stable.\n\nKeywords anynull and null may be specified to deal with undefined pixel values (see documentation for read!).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read!-Tuple{Array, FitsImageHDU}","page":"Reference","title":"Base.read!","text":"read!(arr::DenseArray{<:Number}, hdu::FitsImageHDU[, inds...]) -> arr\n\noverwrites all the elements of the array arr with pixel values read from the FITS image data in hdu and returns arr. Pixel values are converted to the element type of arr.\n\nIf inds... are specified, only the rectangular sub-region defined by inds... is read and the destination array must have the same dimensions as this region (the same rules as for sub-indexing an array are applied to determine the dimensions of the sub-region).\n\nIf inds... are not specified, the complete image is read unless another value than nothing (the default) is given to the keywords first and/or last:\n\nTo read a rectangular sub-image, set keywords first and last with N-tuple of integers indicating the coordinates of the first and last pixels to read. Optionally, keyword step may be set to an N-tuple of integers to indicate the increment along each dimensions. Increments must be positive. Here N is the number of dimensions of the FITS image extension.\nTo read consecutive pixels, specify at least one of the keywords first and/or last with an integer indicating the index of the first and/or last pixels to read.\n\nWhen at least one of the keywords first and/or last is not nothing, the dimensions of the destination arr are not considered. In any case, the number of elements of arr must be equal to the number of pixels to read.\n\nKeyword anynull may be specified with a reference to a boolean (Ref{Bool}()) to retrieve whether any of the read pixels is undefined.\n\nKeyword null may be specified with a reference to a value of the same type as the elements of the destination arr (Ref{eltype(arr)}()) to retrieve the value of undefined pixels. Unless reading a rectangular sub-image, keyword null may be set with an array of Bool of same size as arr and which will be set to true for undefined pixels and to false elsewhere.\n\nOutput arrays arr and null must have contiguous elements, in other words, they must be dense arrays.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.write-Tuple{FitsImageHDU, Array}","page":"Reference","title":"Base.write","text":"write(hdu::FitsImageHDU, arr::AbstractArray{<:Number}) -> hdu\n\nwrites all the elements of the array arr to the pixels of the FITS image extension of the header data unit hdu. The element of arr are converted to the type of the pixels. The default is to write the complete image pixels, so the size of the destination arr must be identical to the dimensions of the FITS image extension. This behavior may be changed by specifying another value than nothing for the keywords first and/or last:\n\nTo write a rectangular sub-image, specify keywords first and last with the coordinates of the first and last pixels to write as an N-tuple of integers, with N the number of dimensions of the FITS image extension.\nTo write consecutive pixels, specify at least one of the keywords first and/or last with the index of the first and/or last pixels to write as an integer.\n\nWhen at least one of the keywords first and/or last is not nothing, the dimensions of arr are not considered. In any case, the number of elements of arr must be equal to the number of pixels to write.\n\nUnless writing a rectangular sub-image, keyword null may be used to specify the value of undefined elements in arr. For integer FITS images, the FITS null value is defined by the BLANK keyword (an error is returned if the BLANK keyword doesn't exist). For floating point FITS images the special IEEE NaN (Not-a-Number) value will be written into the FITS file.\n\n\n\n\n\n","category":"method"},{"location":"library/#FITS-table-HDUs","page":"Reference","title":"FITS table HDUs","text":"","category":"section"},{"location":"library/#EasyFITS.FitsTableHDU","page":"Reference","title":"EasyFITS.FitsTableHDU","text":"hdu = FitsTableHDU(file, cols...)\n\ncreates a new FITS table extension in FITS file file with columns defined by cols.... Each column definition is a pair name => format where name is the column name while format specifies the type of the column values and, optionally, their units and the size of the column cells. The following definitions are possible:\n\nname => type\nname => (type,)\nname => (type, units)\nname => (type, dims)\nname => (type, units, dims)\nname => (type, dims, units)\n\nwhere type is either a Julia type (Number or String) or a letter (see table below), dims is an integer or a tuple of integers, and units is a string. By default, dims = (1,) and units = \"\".\n\nType Letter Remarks\nAbstractString 'A' ASCII string\nBool 'L' \nInt8 'S' CFITSIO specific\nUInt8 'B' \nInt16 'I' \nUInt16 'U' CFITSIO specific\nInt32 'J' \nUInt32 'V' CFITSIO specific\nInt64 'K' \nUInt64 'W' CFITSIO specific\nFloat32 'E' \nFloat64 'D' \nComplex{Float32} 'C' \nComplex{Float64} 'M' \nFitsBit 'X' bits\n\nThe returned object can be used to add FITS keywords to the header of the table and, then, to write column data. Typically:\n\nhdu = FitsTableHDU(file, cols)\npush!(hdu, key1 => val1) # add a first header keyword\n...                      # add other header keywords\nwrite(hdu, col1 => arr1) # write a first column\n...                      # write other columns\n\nwhere key1 => val1, key2 => val2, etc. specify header cards, while col1 => arr1, col2 => arr2, etc. specify columns names and associated data. Such a table may be created in a single call:\n\nwrite(file, [key1 => val1, key2 => val2, ...], [col1 => arr1, col2 => arr2, ...])\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.read-Tuple{FitsTableHDU}","page":"Reference","title":"Base.read","text":"read([Dict,] hdu::FitsTableHDU[, cols[, rows]]) -> dict\n\nreads several columns of the FITS table extension in hdu as a dictionary indexed by the column names. The columns to read can be specified by cols which may be a single column name/index, a tuple/range/vector of column names/numbers, or a colon : to read all columns (the default). Column names may be strings or symbols (not a mixture of these). The rows to read can be specified by rows as a single row index, a unit range of row numbers, or a colon : to read all rows (the default).\n\nKeyword rename is to specify a function to change column names. If unspecified, the column names are left unchanged if keyword case is true and converted to uppercase letters otherwise.\n\nKeyword units can be used to indicate whether to retrieve the units of the columns. If units is String, the values of the dictionary will be 2-tuples (data,units) with data the column data and units the column units as a string. Otherwise, if units is nothing (the default), the values of the dictionary will just be the columns data.\n\nTo avoid the units keyword, the following methods are provided:\n\nread(Dict{String,Array},               hdu[, cols[, rows]])\nread(Dict{String,Tuple{Array,String}}, hdu[, cols[, rows]])\n\nto yield the same result as read(hdu,...) with respectively units=nothing and units=String.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read-Tuple{Type{Vector{T} where T}, FitsTableHDU}","page":"Reference","title":"Base.read","text":"read(Vector, hdu::FitsTableHDU[, cols[, rows]]) -> vec::Vector\n\nreads some columns of the FITS table extension in hdu as a vector. The columns to read can be specified by cols which may be a single column name/index, a tuple/range/vector of column names/numbers, or a colon : to read all columns (the default). Column names may be strings or symbols (not a mixture of these). The rows to read can be specified by rows as a single row index, a unit range of row numbers, or a colon : to read all rows (the default). V is the type of the result.\n\nKeyword units can be used to indicate whether to retrieve the units of the columns. If units is String, the elements of the result will be 2-tuples (data,units) with data the column data and units the column units as a string. Otherwise, if units=nothing (the default), the elements of the result will just be the columns data.\n\nTo avoid the units keyword and allow more control on the type of the result, the following 2 methods are provided:\n\nread(Vector{<:Array},               hdu[, cols[, rows]])\nread(Vector{Tuple{<:Array,String}}, hdu[, cols[, rows]])\n\nto yield the same result as read(hdu,...) with respectively units=nothing and units=String.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read-Tuple{FitsTableHDU, String}","page":"Reference","title":"Base.read","text":"read([R=Array,] hdu::FitsTableHDU, col[, rows]; kwds...) -> vals::R\n\nreads a single column col of the FITS table extension in hdu and returns its values and, possibly, its units.\n\nThe column col may be specified by its name or by its number. If col is a string or a symbol, keyword case specifies whether the case of letters matters (case = false by default).\n\nOptional leading argument R is to specify the type of the result which can be an array type, to only retrieve the column values, or a tuple of array and string types, to retrieve the column values and their units.\n\nOptional argument rows is to specify which rows to read. It can be an integer to read a single row, a unit range of integers to read these rows, or a colon : to read all rows (the default). Use hdu.first_row and hdu.last_row to retrieve the first and last row numbers.\n\nSee read! for the other possible keywords.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read!-Tuple{Dict, FitsTableHDU}","page":"Reference","title":"Base.read!","text":"read!(dict, hdu::FitsTableHDU[, cols[, rows]]) -> dict\n\nmerges the contents of the dictionary dict with the column(s) cols read from the FITS table extension in hdu and returns the dictionary.\n\nPrevious contents of dict is not erased, call read!(empty!(dict),hdu,...) to erase any contents prior to reading.\n\nThe case keyword specify whether to consider the case of characters in column names. By default, case = false.\n\nThe rename keyword may be specified with a function that converts the column names into dictionary keys. If unspecified, the default is to convert column names to uppercase characters if keyword case is false and to leave column names unchanged otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read!-Tuple{Array, FitsTableHDU, String}","page":"Reference","title":"Base.read!","text":"read!(arr::DenseArray, hdu::FitsTableHDU, col) -> arr\n\noverwrites the elements of array arr with values of the column col of the FITS table extension in hdu and returns arr.\n\nThe column col may be specified by its name or by its number. If col is a string or a symbol, keyword case indicates whether the case of letters matters (case = false by default).\n\nKeyword first may be specified with the index of the first row to read. By default, first = hdu.first_row and reading starts at the first row of the table.\n\nKeyword anynull may be specified with a reference to a boolean (Ref{Bool}()) to retrieve whether any of the read values is undefined.\n\nKeyword null may be specified with a reference to a value of the same type as the elements of the destination arr (Ref{eltype(arr)}()) to retrieve the value of undefined values. Keyword null may also be set with an array of Bool of same size as arr and which will be set to true for undefined values and to false elsewhere.\n\nOutput arrays arr and null must have contiguous elements, in other words, they must be dense arrays.\n\n\n\n\n\n","category":"method"},{"location":"library/#FITS-header","page":"Reference","title":"FITS header","text":"","category":"section"},{"location":"library/#FITSHeaders.Headers.FitsHeader-Tuple{FitsHDU}","page":"Reference","title":"FITSHeaders.Headers.FitsHeader","text":"FitsHeader(hdu::FitsHDU)\n\nreads all records of the header of hdu and returns an efficient object representing them.\n\n\n\n\n\n","category":"method"},{"location":"library/#FITS-Header-Data-Units-(HDUs)","page":"Reference","title":"FITS Header Data Units (HDUs)","text":"","category":"section"},{"location":"library/#Base.nameof-Tuple{FitsHDU}","page":"Reference","title":"Base.nameof","text":"nameof(hdu::FitsHDU) -> str\n\nyields the name of the FITS header data unit hdu. The result is the value of the first keyword of \"EXTNAME\" or \"HDUNAME\" which exists and has a string value. If none of these keywords exist, the result is hdu.xtension which is the name of the FITS extension of hdu, that is \"IMAGE\", \"TABLE\", \"BINTABLE\", or \"ANY\" depending on whether hdu is an image, an ASCII table, a binary table, or anything else.\n\n\n\n\n\n","category":"method"},{"location":"library/#EasyFITS.is_named","page":"Reference","title":"EasyFITS.is_named","text":"EasyFITS.is_named(hdu, pat) -> bool\n\nyields whether pattern pat is equal to (in the FITS sense if pat is a string) or matches (if pat is a regular expression) the extension of the FITS header data unit hdu, or to the value of one of its \"EXTNAME\" or \"HDUNAME\" keywords. These are respectively given by hdu.xtension, hdu.extname, or hdu.hduname.\n\nThis method is used as a predicate for the search methods findfirst, findlast, findnext, and findprev.\n\nThe extension hdu.xtension is \"IMAGE\", \"TABLE\", \"BINTABLE\", or \"ANY\" depending on whether hdu is an image, an ASCII table, a binary table, or anything else.\n\n\n\n\n\nEasyFITS.is_named(pat) -> pred\n\nyields e predicate function pred that can be used to check whether pattern pat is equal to (in the FITS sense if pat is a string) or matches (if pat is a regular expression) the extension of the FITS header data units (HDUs).\n\n\n\n\n\n","category":"function"},{"location":"library/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"library/#EasyFITS.OutputCstring","page":"Reference","title":"EasyFITS.OutputCstring","text":"s = EasyFITS.OutputCstring(len)\n\nBuild an object that can be used as an output C string with at most len characters. This object can be passed to a C function where an output string is expected via a ccall as an argument of type Cstring. On return of the C function, the object can be safely converted to a Julia string by calling String(s).\n\n\n\n\n\n","category":"type"},{"location":"library/#EasyFITS.cfitsio_errmsg","page":"Reference","title":"EasyFITS.cfitsio_errmsg","text":"EasyFITS.cfitsio_errmsg(status) -> msg::String\n\nReturn the error message corresponding to CFITSIO status.\n\n\n\n\n\nEasyFITS.cfitsio_errmsg() -> msg::Union{String,Nothing}\n\nRead the oldest CFITSIO error message and discard it. nothing is returned if there are no error messages left.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Notes-for-developers","page":"Notes for developers","title":"Notes for developers","text":"","category":"section"},{"location":"devel/#The-FITS-standard","page":"Notes for developers","title":"The FITS standard","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The FITS format is described in the FITS Standard Document.","category":"page"},{"location":"devel/#The-CFITSIO-sub-module","page":"Notes for developers","title":"The CFITSIO sub-module","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS makes use of the Clang Julia package to automatically build file deps/deps.jl with constants, types, and low level functions to call the functions of the CFITSIO library with arguments of the correct type. All these are available in the EasyFITS.CFITSIO sub-module.","category":"page"},{"location":"devel/#Calls-to-functions-in-the-CFITSIO-library","page":"Notes for developers","title":"Calls to functions in the CFITSIO library","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"When calling functions of the CFITSIO library, there are several things to take care of:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Passing correct arguments. This is partially ensured by the type assertions in the @ccall macro. It is also necessary to check whether a pointer to some opaque structure in the library is valid.\nPreserving objects from being destroyed while being in use. Of course, this is automatically done by Julia for Julia objects, but must be handled for references or pointers to objects provided by the CFITSIO library.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"When an object obj is specified for an argument of type Ptr{T} to be passed to a C function, Julia ccall does something like:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"ref = Base.cconvert(Ptr{T}, obj)\nptr = Base.unsafe_convert(Ptr{T}, ref)\nresult = GC.@preserve ref call_some_c_function(..., ptr, ...)","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Here ref is an object (by default, Base.cconvert(Ptr{T},obj) yields obj itself) to be used with Base.unsafe_convert(Ptr{T},ref) to get the pointer and to be preserved from being garbage collected in order to warrant that the pointer remains valid.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Thanks to this mechanism, it is quite simple to ensure that valid pointers to opaque structures of the CFITSIO library be passed to a function of this library. For example, the code below is how is handled a pointer to a fitsfile C structure in our code:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"isnull(ptr::Ptr{T}) where {T} = ptr === Ptr{T}(0)\ncheck(ptr::Ptr) = isnull(ptr) ? error(\"invalid NULL pointer\") : ptr\nget_handle(file::FitsFile) = getfield(obj, :handle)\nget_file(hdu::AbstractHDU) = getfield(hdu, :file)\nBase.unsafe_convert(Ptr{CFITSIO.fitsfile}, obj::FitsFile) = check(get_handle(obj))\nBase.cconvert(Ptr{CFITSIO.fitsfile}, hdu::AbstractHDU) = get_file(hdu)","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Private methods isnull and check are introduced for readability. Private methods get_handle and get_file are two of the private accessors introduced to hide the fields of a FITS file object and let some other public properties be implemented. The former yields the pointer to the fitsfile C structure that is managed by a FitsFile object, while the latter yields the FitsFile object storing the HDU as it is the one that must be used and preserved when calling a C function requiring a pointer to a fitsfile C structure.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Note that FitsFile objects have a finalizer that automatically releases resources such as the associated fitsfile C structure when the object is garbage collected.","category":"page"},{"location":"devel/#Helper-functions","page":"Notes for developers","title":"Helper functions","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following non-exported functions are provided for meta-programming and for dealing with the types of arguments in calls to the functions of the CFITSIO library.","category":"page"},{"location":"devel/#EasyFITS.cfunc","page":"Notes for developers","title":"EasyFITS.cfunc","text":"EasyFITS.cfunc(pfx::Union{AbstractString,Symbol}, T::Type) -> sym\n\nyields the symbolic name of the function in the CFITSIO library whose prefix is pfx and whose suffix is deduced from the type T. Long/short function names are supported and automatically detected depending on whether pfx ends with an underscore character.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.ctype","page":"Notes for developers","title":"EasyFITS.ctype","text":"EasyFITS.ctype(T) -> Tâ€²\n\nyields the C type equivalent to T in CFITSIO library. This is mostly for Booleans which are treated as C char in the library, the other basic numerical types being unchanged. An error is thrown if the returned type has a different size than that of T. This is to make sure that Julia arrays with elements of type T can safely be used to store values of type Tâ€².\n\nwarning: Warning\nThis only applies to element type of arrays. For boolean scalars, a Cint is the correct type.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.cpointer","page":"Notes for developers","title":"EasyFITS.cpointer","text":"EasyFITS.cpointer(arr::AbstractArray) -> ptr::Ptr{ctype(eltype(arr))}\n\nyields a pointer to the elements of array arr that can be used in calls to functions of the CFITSIO library. Compared to Ptr{Cvoid}(pointer(arr)), this function yields a typed pointer which prevents using arguments of the wrong type.\n\nwarning: Warning\nDo not forget to use GC.@protect arr ... to avoid arr being garbage collected while its address is in use.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Pixel-types","page":"Notes for developers","title":"Pixel types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists conventions used by CFITSIO for pixel types, that is the BITPIX keyword in FITS image extensions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type BITPIX\nBYTE_IMG UInt8 8\nSBYTE_IMG Int8 \nSHORT_IMG Int16 16\nUSHORT_IMG UInt16 \nLONG_IMG Int32 32\nULONG_IMG UInt32 \nLONGLONG_IMG Int64 64\nULONGLONG_IMG UInt64 \nFLOAT_IMG Float32 -32\nDOUBLE_IMG Float64 -64","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Types without a value in the BITPIX column are converted by the CFITSIO library into the other signed/unsigned type using special values of the BSCALE and BZERO keywords to allow for the reciprocal conversion. This is explicitly allowed by the FITS Standard (version 4.0).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/#EasyFITS.type_to_bitpix","page":"Notes for developers","title":"EasyFITS.type_to_bitpix","text":"EasyFITS.type_to_bitpix(T)\n\nyields the code for FITS image pixels of type T. Argument can also be an array instance or type.\n\nBasic numeric types are recognized by this method which may be extended by other packages to yield the CFITSIO codes equivalent to their own types. The CFITSIO constants (to be prefixed by EasyFITS.CFITSIO.) and their corresponding Julia types and standard BITPIX code are:\n\nCFITSIO Constant Julia Type BITPIX\nBYTE_IMG UInt8 8\nSBYTE_IMG Int8 \nSHORT_IMG Int16 16\nUSHORT_IMG UInt16 \nLONG_IMG Int32 32\nULONG_IMG UInt32 \nLONGLONG_IMG Int64 64\nULONGLONG_IMG UInt64 \nFLOAT_IMG Float32 -32\nDOUBLE_IMG Float64 -64\n\nNote that CFITSIO can read/write non-standard pixel types (those without a BITPIX value above) by setting keywords BSCALE and BZERO with special values as explicitly allowed by the FITS Standard (version 4).\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_bitpix","page":"Notes for developers","title":"EasyFITS.type_from_bitpix","text":"EasyFITS.type_from_bitpix(b) -> T\n\nyields the Julia type T corresponding to FITS \"BITPIX\" b.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Array-data-types","page":"Notes for developers","title":"Array data types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists conventions used by CFITSIO for array element types.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code C Type Short Suffix Long Suffix\nTLOGICAL char l _log\nTBYTE unsigned char b _byt\nTSBYTE signed char sb _sbyt\nTUSHORT unsigned short ui _usht\nTSHORT short i _sht\nTUINT unsigned int uk _uint\nTINT int k _int\nTULONG unsigned long uj _ulng\nTLONG long j _lng\nTULONGLONG unsigned long long ujj _ulnglng\nTLONGLONG long long jj _lnglng\nTFLOAT float e _flt\nTDOUBLE double d _dbl\nTCOMPLEX float complex c _cmp\nTDBLCOMPLEX double complex m _dblcmp\nTSTRING char* s _str\nTBIT  x _bit\n  u _null","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Complex types float complex and double complex are stored as pairs of single/double precision floating-point values (this is not guaranteed by C99 standard so strict equivalence does not hold here).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/#EasyFITS.type_to_code","page":"Notes for developers","title":"EasyFITS.type_to_code","text":"EasyFITS.type_to_code(T)\n\nyields the CFITSIO type code for a keyword value or table cells of type T. Argument can also be an array instance or type.\n\nBasic numeric types and string types are recognized by this method which may be extended by other packages to yield the CFITSIO codes equivalent to their own types. The CFITSIO type constants (to be prefixed by EasyFITS.CFITSIO.) and their corresponding C and Julia types are:\n\nCFITSIO Constant C Types Julia Types\nTLOGICAL char Cchar, Bool\nTBYTE unsigned char UInt8, Bool\nTSBYTE signed char Int8\nTUSHORT unsigned short Cushort\nTSHORT short Cshort\nTUINT unsigned int Cuint\nTINT int Cint\nTULONG unsigned long Culong\nTLONG long Clong\nTULONGLONG unsigned long long Culonglong\nTLONGLONG long long Clonglong\nTFLOAT float Cfloat\nTDOUBLE double Cdouble\nTCOMPLEX float complex Complex{Cfloat}\nTDBLCOMPLEX double complex Complex{Cdouble}\nTSTRING char* \nTBIT  \n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_code","page":"Notes for developers","title":"EasyFITS.type_from_code","text":"EasyFITS.type_from_code(c) -> T\n\nyields the Julia type T corresponding to CFITSIO type code c.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Column-data-types","page":"Notes for developers","title":"Column data types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists the correspondences between the TFORMn letter in FITS table extensions and the column data type.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type TFORM Description\nTLOGICAL Bool â€™Lâ€™ Logical (1 byte)\nTBIT  â€™Xâ€™ Bit (special)\nTBYTE UInt8 â€™Bâ€™ 8-bit unsigned integer\nTSHORT Int16 â€™Iâ€™ 16-bit signed integer\nTLONG Int32 â€™Jâ€™ 32-bit signed integer\nTLONGLONG Int64 â€™Kâ€™ 64-bit signed integer\nTSTRING String â€™Aâ€™ Character (1 byte, used for strings)\nTFLOAT Float32 â€™Eâ€™ 32-bit floating point\nTDOUBLE Float64 â€™Dâ€™ 64-bit floating point\nTCOMPLEX ComplexF32 â€™Câ€™ 64-bit complex\nTDBLCOMPLEX ComplexF64 â€™Mâ€™ 128-bit complex\n  â€™Pâ€™ 32-bit array descriptor\n  â€™Qâ€™ 64-bit array descriptor","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"A few non-standard TFORM letters are allowed by CFITSIO. These are converted by the library into other types using TSCALE and TZERO keywords to allow for the reciprocal conversion following the same principles as for the BITPIX code and the BSCALE and BZERO keywords.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type TFORM Description\nTSBYTE Int8 â€™Sâ€™ 8-bit signed integer\nTUSHORT UInt16 â€™Uâ€™ 16-bit unsigned integer\nTULONG UInt32 â€™Vâ€™ 32-bit unsigned integer\nTULONGLONG UInt64 â€™Wâ€™ 64-bit unsigned integer","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The Type Code column indicates the code used by CFITSIO (it is not always consistent with the C types as defined in the above table, so my guess is that this code is only used to keep track of the column data type internally).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/#EasyFITS.type_to_letter","page":"Notes for developers","title":"EasyFITS.type_to_letter","text":"EasyFITS.type_to_letter(T)\n\nyields the letter of the TFORMn keyword representing table cells of type T in FITS. Argument can also be an array instance or type.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_letter","page":"Notes for developers","title":"EasyFITS.type_from_letter","text":"EasyFITS.type_from_letter(c) -> T\n\nyields the Julia type T corresponding to CFITSIO column type letter c as assumed for the TFORMn keywords.\n\n\n\n\n\n","category":"function"},{"location":"images/#FITS-Image-HDUs","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"","category":"section"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"FITS Image HDUs store multi-dimensional arrays with numerical values exactly as regular Julia arrays. In EasyFITS, a FITS Image HDU is represented by an object of type FitsImageDHU{T,N} with T the element type and N the number of dimensions.","category":"page"},{"location":"images/#Image-HDU-properties","page":"FITS Image HDUs","title":"Image HDU properties","text":"","category":"section"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"An image HDU has the following properties:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"Property Description\ndata_size Array dimensions\ndata_axes Array axes\ndata_ndims Number of dimensions N\ndata_eltype Element type T\nextname Extension name\nhduname HDU name\nfile Associated i/o FITS file\nnumber HDU number\ntype HDU type, i.e. FITS_IMAGE_HDU\nxtension Extension name, i.e. \"IMAGE\"","category":"page"},{"location":"images/#Reading-a-FITS-image","page":"FITS Image HDUs","title":"Reading a FITS image","text":"","category":"section"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"To read the data stored by the Header Data Unit (HDU) object hdu of type FitsImageDHU HDU as an array arr, call read as:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"arr = read(hdu)","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"The result is type-stable: arr is of type Array{T,N} if hdu isa FitsImageDHU{T,N} holds. To choose another element type, say, S, just do:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"arr = read(Array{S}, hdu)","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"This is similar but more efficient than any of:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"arr = S.(read(hdu))\narr = convert(Array{S}, read(hdu))","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"The expected number of dimension, say N, may also be specified. For example:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"arr = read(Array{Float32,2}, hdu)\narr = read(Matrix{Float32}, hdu)","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"both warrant that arr will be a 2-dimensional image with pixels of type Float32.","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"Call read! to overwrite the elements of an existing array with the contents of the FITS image HDU. For example:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"read!(arr, hdu)","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"An hyper-rectangular sub-image can be read using the same syntax as for a Julia view by specifying indices, index ranges, or colons after the hdu argument. Index ranges may have non-unit steps but steps must all be positive. For example:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"arr = read(hdu, :, :, 2)","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"yields the 2nd slice in a 3-dimensional FITS image.","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"The result is similar to:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"arr = read(R, hdu)[:,:,2]","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"but should be more efficient as no array other than the result is allocated and fewer values are read.","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"Call read! instead of read to overwrite the contents of an existing array. Following the previous example, reading the next slice could be done by:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"read!(arr, hdu, :, :, 3)","category":"page"},{"location":"images/#Creating-an-image-HDU","page":"FITS Image HDUs","title":"Creating an image HDU","text":"","category":"section"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"To create a new FITS image HDU in an open FITS file, there are several possibilities:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"hdu = FitsImageHDU(file, dims...; bitpix=...)\nhdu = FitsImageHDU{T}(file, dims...)\nhdu = FitsImageHDU{T,N}(file, dims...)","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"with pixel type specified by its Julia data-type via the parameter T or by its FITS BITPIX code via the keyword bitpix and image size given by dims.... The number of dimensions N can be inferred from the image size but may be explicitly specified for better type-stability.","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"If the FITS file is currently empty then a primary array is created, otherwise a new image HDU is appended to the file.","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"The returned hdu is an object to manage the new HDU, it can be used to push header cards and then to write the data.","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"If the array arr to be written is available, the element type and dimensions can be inferred from arr itself:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"hdu = FitsImageHDU(file, arr)\nhdu = FitsImageHDU{T}(file, arr)\nhdu = FitsImageHDU{T,N}(file, arr)","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"where T = eltype(arr) and N = ndims(arr) are assumed if these parameters are not explicitly specified. Specifying a different pixel type than eltype(arr) is possible, conversion will automatically be performed when writing the array values.","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"For example:","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"hdu = FitsImageHDU(file, arr)\nhdu[\"KEY1\"] = val1             # add a 1st header record\nhdu[\"KEY2\"] = (val2, str2)     # add a 2nd header record\nhdu[\"KEY3\"] = (nothing, str3)  # add a 3rd header record\nwrite(hdu, arr)                # write data","category":"page"},{"location":"images/","page":"FITS Image HDUs","title":"FITS Image HDUs","text":"will create a new Header Data Unit (HDU) storing array arr with 3 additional header records: one named \"KEY1\" with value val1 and no comments, another named \"KEY2\" with value val2 and comment string str2, and yet another one named \"KEY3\" with no value and with comment string str3. Note that special names \"COMMENT\", \"HISTORY\", and \"\" indicating commentary entries have no associated, only a comment string, say str which can be specified as str or as (nothing,str).","category":"page"},{"location":"links/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"links/","page":"Index","title":"Index","text":"","category":"page"},{"location":"files/#Navigating-in-FITS-files","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"","category":"section"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"This section explains how to open and navigate into a FITS file, that is move to a given HDU.","category":"page"},{"location":"files/#Open-a-FITS-file","page":"Navigating in FITS files","title":"Open a FITS file","text":"","category":"section"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"In EasyFITS, a FITS file is represented by an instance of FitsFile. To create a new FITS file or to open an existing FITS file, simply call the FitsFile constructor:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"file = FitsFile(filename, mode=\"r\"; extended=false)","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"with filename the name of the FITS file and one of the following modes:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"\"r\" (the default) to open an existing FITS file for reading only.\n\"r+\" to open an existing FITS file for reading and appending to its contents.\n\"w\" to create a new FITS file, throwing an error if the file already exists.\n\"w!\" to create a new FITS file, silently overwriting the file if it already exists.","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"The extended keyword specifies whether to use the extended file name syntax implemented by the CFITSIO library.","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"It is not mandatory to call close(file) to close the FITS file, this is automatically done when the file object is garbage collected. Calling close(file) is however needed to ensure that a FITS file open for writing is up to date before file be garbage collected. To make sure the file contents is up to date without explicitly closing it, call flush(file) instead. To automatically close a FITS file, use the do-block syntax:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"FitsFile(\"test.fits.gz\", \"w!\") do file\n    do_something_with(file)\nend","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"Standard Julia methods for file-like objects are available for an open FITS file:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"isopen(file) # yields whether file is open\nclose(file) # close the file\npathof(file) # yields the path to the file\nfilemode(file) # yields the mode `:r` or `:w`\nisreadable(file) # yields whether file is readable\nisreadonly(file) # yields whether file is readable and not writable\niswritable(file) # yields whether file is writable","category":"page"},{"location":"files/#Indexing-and-searching-HDUs","page":"Navigating in FITS files","title":"Indexing and searching HDUs","text":"","category":"section"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"An instance, say file, of FitsFile can be thought as an abstract vector of FITS HDUs indexed by their number: file[1] is the primary HDU, file[2] is the second HDU, file[end] is the last HDU, and so on.","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"The index may also be the HDU name (given by the HDUNAME or EXTNAME keywords) or a predicate function. For example:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"hdu = file[x -> nameof(x) == \"SOME_NAME\"]\nhdu = file[\"SOME_NAME\"]","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"both yield the first HDU in file whose name is \"SOME_NAME\". In the latter case, the comparison is done ignoring letter case as assumed by FITS standard for comparing strings.","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"To find the index of the first (resp. last) HDU matching w call:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"i = findfirst(w, file)\ni = findlast(w, file)","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"where w is a string, a regular expression or a predicate function. On return, i is nothing if no match is found and an integer index otherwise. Then, to find the next (resp. previous) HDU matching w after (resp. before) start, call:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"i = findnext(w, file, start)\ni = findprev(w, file, start)","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"which also return nothing or an integer. The method eachmatch may be used to execute some code on each HDU matching w:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"for hdu in eachmatch(w, file)\n    ... # do something\nend","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"haskey(file::FitsFile, key::Union{AbstractString,Integer})\nget(file::FitsFile, key::Union{AbstractString,Integer}, def)","category":"page"},{"location":"files/#Stream-like-operations","page":"Navigating in FITS files","title":"Stream-like operations","text":"","category":"section"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"A FitsFile instance may also be thought as a stream of HDUs:","category":"page"},{"location":"files/","page":"Navigating in FITS files","title":"Navigating in FITS files","text":"seek(file, n)\nhdutype = seekstart(file::FitsFile)\nhdutype = seekend(file::FitsFile)\nhdunum = position(file::FitsFile)\nflush(f::Union{FitsFile,FitsHDU})","category":"page"},{"location":"structure/#Structure-of-FITS-files","page":"Structure of FITS files","title":"Structure of FITS files","text":"","category":"section"},{"location":"structure/","page":"Structure of FITS files","title":"Structure of FITS files","text":"A FITS file is a collection of Header Data Units (HDUs). The first HDU of a FITS file is called the Primary HDU, other HDUs are called extenstions. Each HDU consists in two parts: the header part is a list of FITS keywords which have a name and, usually, a value and a comment; the data part may be a multi-dimensional array or a table. The primary HDU and so-called FITS Image extensions are HDUs storing a multi-dimensional array in their data part, while FITS Table extensions are HDUs storing a table in their data part. The HDUs of a FITS file are indexed by their number (starting at 1 for the primary HDU) or by their name (specified by the value of the HDUNAME or EXTNAME keyword of their header part). The first HDU which must be an image may be empty. Arrays stored in FITS Image extensions have elements of the same numeric type and may have 1 to 999 dimensions. Tables stored in FITS Image extensions may have a variable number of columns identified by their names, their entries (at a given row and column) are called cells and may have multiple dimensions. Generally, all cells of a given column have the same data type and dimensions. FITS headers are stored in textual form encoded with a restricted subset of the ASCII characters. Although FITS supports ASCII Tables, the data part of FITS HDUs is generally in binary format (in big endian byte order and following IEEE stabdard for floating point values).","category":"page"},{"location":"structure/","page":"Structure of FITS files","title":"Structure of FITS files","text":"References and related resources:","category":"page"},{"location":"structure/","page":"Structure of FITS files","title":"Structure of FITS files","text":"The IAU FITS Working Group maintains the FITS standard and endorses its evolution.\nThe NASA FITS Standard Document hosts the offical reference document that defines the FITS format.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"EasyFITS is a Julia package for reading and writing files in FITS format, a Flexible Image Transport System, widely used in astronomy.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code of EasyFITS is on GitHub.","category":"page"},{"location":"#Related-software","page":"Introduction","title":"Related software","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FITSHeaders is used by EasyFITS to efficiently manage FITS header cards. You may read FITSHeaders documentation to learn how to deal with FITS header cards when using EasyFITS.\nCFITSIO is the standard C library for managing FITS files and is used by EasyFITS.\nFITSIO.jl is another Julia package for reading/writing with FITS files. FITSIO.jl is also based on the CFITSIO C library. Compared to FITSIO.jl, EasyFITS attempts to be more intuitive and more type-stable.\nCFITSIO_jll is the Julia  artifact providing the CFITSIO C library used by the EasyFITS and FITSIO.jl  packages.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"structure.md\", \"reading.md\", \"writing.md\", \"files.md\",\"images.md\", \"tables.md\", \"library.md\", \"links.md\"]","category":"page"},{"location":"reading/#Reading-FITS-files","page":"Reading FITS files","title":"Reading FITS files","text":"","category":"section"},{"location":"reading/#Direct-reading-of-FITS-data","page":"Reading FITS files","title":"Direct reading of FITS data","text":"","category":"section"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"The simplest way to read some data in a FITS file is to call readfits:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"data = readfits(filename, args...; kwds...)","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"where filename is the name of the file while args... and kwds... are optional arguments and keywords to specify which HDU and which part of the data to read.","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"By default, the returned data are read in the first FITS extension of filename. Keyword ext may however be set with a number, a name, or a predicate function to select another extension. Another possibility is to specify the keyword extended = true to open the file using the extended file name syntax implemented by the CFITSIO library.","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"If no optional arguments args... are specified, all the data part of the selected FITS HDU is read and returned. Otherwise, arguments args... indicate which part the HDU data to read:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"For a FITS Image HDU, args... specifies the ranges of pixels to read along the dimensions with a syntax similar to that of sub-arrays or views in Julia. For example:\ndata = readfits(filename, :, :, 5)\nwould read the 5th slice in a 3-dimensional image. This is equivalent but more efficient than:\ndata = readfits(filename)[:, :, 5]\nwhich amounts to reading all the data and then only keep the 5th slice.\nFor a FITS Table HDU, args... may be up to 2 arguments, say cols and rows, to respectively select a subset of columns and rows (if the latter is not specified, all rows of the table are read). For example:\nA = readfits(filename, (\"Speed\", \"Height\"))\nB = readfits(filename, :, 11:40)\nrespectively yield the columns named Speed and Height of the table and all the columns of the table but only for rows in the range 11:40. Keyword case may be used to indicate whether letter case does matter in the column names.","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"!!! note      In EasyFITS, the rows of a table correspond to the last dimension of arrays. This      is to have the same storage order in memory and in the FITS file. Method      permutedims can be used is this convention does not suit you.","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"The type of the object returned by readfits depends on the kind of the FITS extension and may also depend on the optional arguments args...:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"For a FITS Image HDU, the read data is returned as a Julia Array.\nFor a FITS Table HDU, if cols is a single column name or number, an array of the columns values is returned, otherwise, a dictionary indexed by the column names is returned. Note that, a column range like 4:4 would yield a dictionary with a single column (the 4th one). Keywords case and rename are available to indicate how to search the columns by name in the table and how to translate these names into dictionary keys.","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"To avoid ambiguities or for improved type-stability, an optional leading type argument can be specified in readfits to indicate the expected type of the returned data:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"data = readfits(R::Type, filename, args...; kwds...)","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"which warrants that data isa R holds. For a FITS Image extension, array type parameters such as the element type and the number of dimensions may be specified in R. For example:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"data = readfits(Array{Float32,3}, filename)","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"ensures that data is a single precision floating-point 3-dimensional array; while:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"data = readfits(Dict, filename, cols; ext=2)","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"ensures that the table in 2nd FITS Header Data Unit is returned as a dictionary even though cols specifies a single column.","category":"page"},{"location":"reading/#Direct-reading-of-a-FITS-header","page":"Reading FITS files","title":"Direct reading of a FITS header","text":"","category":"section"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"For efficiency, FITS headers are returned as instances of FitsHeader provided by the FITSHeaders package. To avoid type piracy, there is as yet no direct method of reading a FITS header. The most compact way to read the header of a known FITS HDU is to do:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"hdr = FitsHeader(FitsFile(filename)[ext])","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"where filename is the name of the file and ext is an HDU number, name, or a predicate function to read the first HDU for which the predicate function yields true. The above one-liner exploits the fact that FITS files are automatically closed when garbage collected.","category":"page"},{"location":"reading/#Advanced-reading-of-FITS-files","page":"Reading FITS files","title":"Advanced reading of FITS files","text":"","category":"section"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"Direct reading of a FITS file with readfits is suitable to read the data of a single FITS HDU at a known location (HDU number or name). More advanced operations such as reading several pieces of data, searching the file, checking the contents, etc., can be performed by the following steps:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"Open the FITS file for reading with the FitsFile constructor.\nMove to the FITS HDU of interest (see Indexing and searching HDUs).\nRead some HDU content: read the header, read image pixels, read a table column, or read several table columns.\nEventually close the FITS file with close. Closing the FITS file is automatically done when the object representing the file is no longer used and garbage collected, closing the file is therefore optional.","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"Remarks:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"Steps 2 and 3 can be repeated as many times as necessary to read more data and/or other headers.\nIn-place reading is also possible with read!(dest, hdu, ...).","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"For example, reading the data and the header of the HDU at ext in FITS file named filename is done by:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"file = FitsFile(filename)\nhdu = file[ext]\nhdr = FitsHeader(hdu)\ndata = read(hdu)\nclose(file)","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"or, using the do-block syntax:","category":"page"},{"location":"reading/","page":"Reading FITS files","title":"Reading FITS files","text":"hdr, data = FitsFile(filename) do file\n    hdu = file[ext]\n    FitsHeader(hdu), read(hdu)\nend","category":"page"},{"location":"tables/#FITS-Table-HDUs","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"","category":"section"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"FITS Table HDUs store table data. In a given table column, cells may contain more than a single value. In EasyFITS, a FITS Table HDU is represented by an object of type FitsTableDHU.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"note: Note\nThe elements of a column of a FITS table HDU are stored in the same memory order as in an ordinary Julia array. As a result, the rows of a column in a FITS table HDU correspond to the last index in the equivalent Julia array. Method permutedims can be used is this convention does not suit you.","category":"page"},{"location":"tables/#Reading-a-single-table-column","page":"FITS Table HDUs","title":"Reading a single table column","text":"","category":"section"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"To read a single column in a FITS table HDU as an array arr, call read as:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"arr = read(hdu, col)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"with hdu the Header Data Unit containing the table and col the column name or number. The names of the columns are given by hdu.column_names and valid column numbers are in the range hdu.columns (see Table HDU Properties for a list of all properties). If col is a string or a symbol, keyword case can be used to specify whether uppercase/lowercase matters (case is false by default).","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"By default, all rows are read but it is possible to specify which rows to read:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"arr = read(hdu, col, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"where rows can be an integer to read a single row, a unit range of integers to read these rows, or a colon : to read all the rows (the default). Properties hdu.first_row and hdu.last_row can be used to retrieve the first and last row numbers of hdu.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"The read method automatically guess the number of dimensions and the type of the elements of the Julia array representing the column of a table. To improve type stability, the read method takes an optional first argument to specify the type of the result, from the least specific Array to Array{T} or Array{T,N}. For instance:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"arr = read(Vector{Float32}, hdu, col)\narr = read(Vector{Float32}, hdu, col, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"are both guaranteed to yield an instance of Vector{Float32} (an exception is thrown if the elements of the column cannot be converted to the given type or if the column cells are not scalar numbers).","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"In fact, the calls read(hdu,col) and read(hdu,col,rows) are respectively equivalent to read(Array,hdu,col) and read(Array,hdu,col,rows).","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"The read! method can be called to overwrite the contents of an existing array (it must have contiguous entries) with the cells of a column:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"read!(arr, hdu, col)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"where keyword first may be used to specify the first row to read (the first one, hdu.first_row, by default), the number of rows to read being deduced from the size of arr. Other keywords are anynull and null to deal with undefined values.","category":"page"},{"location":"tables/#Reading-several-table-columns","page":"FITS Table HDUs","title":"Reading several table columns","text":"","category":"section"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"In the most simple form, reading several table columns is done by one of:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"dict = read(hdu, cols)\ndict = read(hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"where, as for reading a single column, hdu is the Header Data Unit containing the table and rows may be specified to select the rows to read but cols is a vector or a tuple of column names/numbers, or a colon : to read all columns. Specify keyword case=true if columns are specified by their (symbolic) names and the case of these names matters.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"The result of reading several columns is a dictionary whose keys are the names of the columns and whose values are the cells of the columns. The keys of the dictionary are the names of the table columns unconverted if keyword case=true and converted to upper-case letters otherwise. If this is not suitable, use the keyword rename to specify a function to modify the names of the columns. For example, with rename=identity the names of the columns will be left unchanged whatever the keyword case while with rename=lowercase the names of the columns will be converted to lower-case letters.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"In order to retrieve the units of the columns, specify keyword units=String and get a dictionary whose values are 2-tuples of the form (data,units) with data the column cells and units the column units as a string. The default behavior, that is to get a dictionary whose values are simply be the cells of the columns, corresponds to units=nothing.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"To have a dictionary when cols is a single column name/number, just specify the type of the expected result as the leading argument. For example:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"dict = read(Dict, hdu)\ndict = read(Dict, hdu, cols)\ndict = read(Dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"Of course, this also works if the cols argument represents several columns without ambiguities.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"The leading type argument may be more specific. For example:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"dict = read(Dict{String,Array}, hdu, cols)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"is the same as with Dict, while:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"dict = read(Dict{String,Vector}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"can only be successful if all read columns have 0-dimensional cells.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"If the leading argument is more specific than Dict, the units=String keyword is not allowed and retrieving the units is done by specifying that the values are tuples of an array and a string. For example:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"dict = read(Dict{String,Tuple{Array,String}}, hdu, cols)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"Using the leading type argument, it is also possible to retrieve a vector of the table columns (in the same order as specified in cols). For example:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"vect = read(Vector, hdu, cols)\nvect = read(Vector, hdu, cols, rows)\nvect = read(Vector{Array}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"It is also possible to retrieve the units at the same time:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"vect = read(Vector, hdu, cols; units=String)\nvect = read(Vector, hdu, cols, rows; units=String)\nvect = read(Vector{Tuple{Array,String}}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"With the read! method, the contents of an existing dictionary may be replaced by columns from a FITS table:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"read!(dict, hdu)\nread!(dict, hdu, cols)\nread!(dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"where, as for the read method, keywords case and rename may be supplied. Call the merge! method instead to preserve pre-existing contents:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"merge!(dict, hdu)\nmerge!(dict, hdu, cols)\nmerge!(dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"With the push! method, a vector of columns can be augmented with additional columns:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"push!(vect, hdu)\npush!(vect, hdu, cols)\npush!(vect, hdu, cols, rows)","category":"page"},{"location":"tables/#Creating-a-table-HDU","page":"FITS Table HDUs","title":"Creating a table HDU","text":"","category":"section"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"To create a new FITS table HDU in the FITS file file, call:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"hdu = write(file, FitsTableHDU, cols)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"with cols defining the columns of the table. Each column definition is a pair name => format where name is the column name while format specifies the type of the column values and, optionally, their units and the size of the column cells. The following definitions are possible:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"name => type\nname => (type,)\nname => (type, units)\nname => (type, dims)\nname => (type, units, dims)\nname => (type, dims, units)","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"where type is either a Julia type (Number or String) or a letter (see table below), dims is an integer or a tuple of integers, and units is a string. By default, dims = (1,) and units = \"\".","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"Type Letter Remarks\nAbstractString 'A' ASCII string\nBool 'L' \nInt8 'S' CFITSIO specific\nUInt8 'B' \nInt16 'I' \nUInt16 'U' CFITSIO specific\nInt32 'J' \nUInt32 'V' CFITSIO specific\nInt64 'K' \nUInt64 'W' CFITSIO specific\nFloat32 'E' \nFloat64 'D' \nComplex{Float32} 'C' \nComplex{Float64} 'M' \nFitsBit 'X' bits","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"The returned object, hdu, can be used to add FITS keywords to the header of the table and, then, to write column data. Typically:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"hdu = write(file, FitsTableHDU, cols)\npush!(hdu, key1 => val1)         # add a first header keyword\npush!(hdu, key2 => (val2, com2)) # add a second header keyword with a comment\n...                              # add other header keywords\nwrite(hdu, col1 => arr1)         # write a first column\nwrite(hdu, col2 => arr2)         # write a second column\n...                              # write other columns","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"where key1 => val1, key2 => (val2,com2), etc. specify header cards, while col1 => arr1, col2 => arr2, etc. specify columns names and associated data. Such a table may be created in a single call:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"write(file,\n      [key1 => val1, key2 => (val2, com2), ...],\n      [col1 => arr1, col2 => arr2, ...])","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"which follows the write(dest, header, data) convention in EasyFITS with dest the destination, header the header, and data the data.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"The header may be specified in any forms accepted by the EasyFITS methods. Similarly, the columns may be specified in various forms as explained below.","category":"page"},{"location":"tables/#Writing-table-columns","page":"FITS Table HDUs","title":"Writing table columns","text":"","category":"section"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"To write a single column into the FITS table HDU hdu:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"write(hdu, col => arr, ...; first=hdu.first_row, case=false, null=nothing) -> hdu","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"where col is the column name/number and arr is an array of column values. Column values are converted as needed and are written starting at the row specified by first. The leading dimensions of arr should be the same as those specified by the corresponding TDIMn keyword (with n the column number) and the remaining last dimension, if any, corresponds to the row index of the table.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"If col is a column name, keyword case may be used to indicate whether case of letters matters (default is false).","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"Keyword null may be used to specify the value of undefined elements in arr.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"Any number of columns may be specified as subsequent arguments. The same keywords apply to all columns.","category":"page"},{"location":"tables/#Table-HDU-Properties","page":"FITS Table HDUs","title":"Table HDU Properties","text":"","category":"section"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"The following table lists all properties of a FITS table HDU.","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"Property Description\nnrows Number of rows\nrows Index range of rows\nfirst_row Index of first row\nlast_row Index of last row\nncols Number of columns\ncolumns Index range of columns\nfirst_column Index of first column\nlast_column Index of last column\ncolumn_name Column name accessor\ncolumn_names Column names\ncolumn_number Column number accessor\ncolumn_units Column units accessor\ndata_size Table dimensions\ndata_ndims Number of table dimensions\ndata_axes Indices along table dimensions\nextname Extension name\nhduname HDU name\nfile Associated FITS file\nnum HDU number\ntype HDU type: FITS_BINARY_TABLE_HDU or FITS_ASCII_TABLE_HDU\nxtension Extension name: \"BINTABLE\" or \"TABLE\"","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"To retrieve the units, the number, or the name of column col in the FITS table hdu object, use the properties column_units, column_number, or column_name properties as follows:","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"hdu.column_units(col; case=false) -> units::String\nhdu.column_name(col; case=false) -> name::String\nhdu.column_number(col; case=false) -> number::Int","category":"page"},{"location":"tables/","page":"FITS Table HDUs","title":"FITS Table HDUs","text":"Keyword case specifies whether the case of letters does matters when col is a (symbolic) name. The result of hdu.column_units(col) is always a string, possibly empty.","category":"page"}]
}
