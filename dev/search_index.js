var documenterSearchIndex = {"docs":
[{"location":"tables/#FITS-Table-extensions","page":"FITS Table extensions","title":"FITS Table extensions","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"In a given table column, cells may contain more than a single value.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"note: Note\nThe elements of a column of a FITS table extension are stored in the same memory order as in a Julia array. As a result, the rows of a column in a FITS table extension correspond to the last index in the equivalent Julia array. Method permutedims can be used is this convention does not suit you.","category":"page"},{"location":"tables/#Reading-a-single-table-column","page":"FITS Table extensions","title":"Reading a single table column","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To read a single column in a FITS table extension as an array arr, call read as:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"arr = read(hdu, col)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"with hdu the Header Data Unit containing the table and col the column name or number. The names of the columns are given by hdu.column_names and valid column numbers are in the range hdu.first_column:hdu.last_column (see Table HDU Properties for a list of all properties). If col is a string or a symbol, keyword case can be used to specify whether uppercase/lowercase matters (case is false by default).","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"By default, all rows are read but it is possible to specify which rows to read:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"arr = read(hdu, col, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where rows can be an integer to read a single row, a unit range of integers to read these rows, or a colon : to read all the rows (the default). Properties hdu.first_row and hdu.last_row can be used to retrieve the first and last row numbers of hdu.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The read method automatically guess the number of dimensions and the type of the elements of the Julia array representing the column of a table. To improve type stability, the read method takes an optional first argument to specify the type of the result, from the least specific Array to Array{T} or Array{T,N}. For instance:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"arr = read(Vector{Float32}, hdu, col)\narr = read(Vector{Float32}, hdu, col, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"are both guaranteed to yield an instance of Vector{Float32} (an exception is thrown if the elements of the column cannot be converted to the given type or if the column cells are not scalar numbers).","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"In fact, the calls read(hdu,col) and read(hdu,col,rows) are respectively equivalent to read(Array,hdu,col) and read(Array,hdu,col,rows).","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The read! method can be called to overwrite the contents of an existing array (it must have contiguous entries) with the cells of a column:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"read!(arr, hdu, col)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where keyword first may be used to specify the first row to read (the first one, hdu.first_row, by default), the number of rows to read being deduced from the size of arr. Other keywords are anynull and null to deal with undefined values.","category":"page"},{"location":"tables/#Reading-several-table-columns","page":"FITS Table extensions","title":"Reading several table columns","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"In the most simple form, reading several table columns is done by one of:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(hdu, cols)\ndict = read(hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where, as for reading a single column, hdu is the Header Data Unit containing the table and rows may be specified to select the rows to read but cols is a vector or a tuple of column names/numbers, or a colon : to read all columns. Specify keyword case=true if columns are specified by their (symbolic) names and the case of these names matters.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The result of reading several columns is a dictionary whose keys are the names of the columns and whose values are the cells of the columns. The keys of the dictionary are the names of the table columns unconverted if keyword case=true and converted to upper-case letters otherwise. If this is not suitable, use the keyword rename to specify a function to modify the names of the columns. For example, with rename=identity the names of the columns will be left unchanged whatever the keyword case while with rename=lowercase the names of the columns will be converted to lower-case letters.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"In order to retrieve the units of the columns, specify keyword units=String and get a dictionary whose values are 2-tuples of the form (data,units) with data the column cells and units the column units as a string. The default behavior, that is to get a dictionary whose values are simply be the cells of the columns, corresponds to units=nothing.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To have a dictionary when cols is a single column name/number, just specify the type of the expected result as the leading argument. For example:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(Dict, hdu)\ndict = read(Dict, hdu, cols)\ndict = read(Dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Of course, this also works if the cols argument represents several columns without ambiguities.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The leading type argument may be more specific. For example:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(Dict{String,Array}, hdu, cols)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"is the same as with Dict, while:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(Dict{String,Vector}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"can only be successful if all read columns have 0-dimensional cells.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"If the leading argument is more specific than Dict, the units=String keyword is not allowed and retrieving the units is done by specifying that the values are tuples of an array and a string. For example:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"dict = read(Dict{String,Tuple{Array,String}}, hdu, cols)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Using the leading type argument, it is also possible to retrieve a vector of the table columns (in the same order as specified in cols). For example:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"vect = read(Vector, hdu, cols)\nvect = read(Vector, hdu, cols, rows)\nvect = read(Vector{Array}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"It is also possible to retrieve the units at the same time:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"vect = read(Vector, hdu, cols; units=String)\nvect = read(Vector, hdu, cols, rows; units=String)\nvect = read(Vector{Tuple{Array,String}}, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"With the read! method, the contents of an existing dictionary may be replaced by columns from a FITS table:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"read!(dict, hdu)\nread!(dict, hdu, cols)\nread!(dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where, as for the read method, keywords case and rename may be supplied. Call the merge! method instead to preserve pre-existing contents:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"merge!(dict, hdu)\nmerge!(dict, hdu, cols)\nmerge!(dict, hdu, cols, rows)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"With the push! method, a vector of columns can be augmented with additional columns:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"push!(vect, hdu)\npush!(vect, hdu, cols)\npush!(vect, hdu, cols, rows)","category":"page"},{"location":"tables/#Creating-a-table-extension","page":"FITS Table extensions","title":"Creating a table extension","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To create a new FITS table extension in the FITS file file, call:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"hdu = write(file, FitsTableHDU, cols)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"with cols defining the columns of the table. Each column definition is a pair name => format where name is the column name while format specifies the type of the column values and, optionally, their units and the size of the column cells. The following definitions are possible:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"name => type\nname => (type,)\nname => (type, units)\nname => (type, dims)\nname => (type, units, dims)\nname => (type, dims, units)","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where type is either a Julia type (Number or String) or a letter (see table below), dims is an integer or a tuple of integers, and units is a string. By default, dims = (1,) and units = \"\".","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Type Letter Remarks\nAbstractString 'A' ASCII string\nBool 'L' \nInt8 'S' CFITSIO specific\nUInt8 'B' \nInt16 'I' \nUInt16 'U' CFITSIO specific\nInt32 'J' \nUInt32 'V' CFITSIO specific\nInt64 'K' \nUInt64 'W' CFITSIO specific\nFloat32 'E' \nFloat64 'D' \nComplex{Float32} 'C' \nComplex{Float64} 'M' \nFitsBit 'X' bits","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The returned object, hdu, can be used to add FITS keywords to the header of the table and, then, to write column data. Typically:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"hdu = write(file, FitsTableHDU, cols)\npush!(hdu, key1 => val1)         # add a first header keyword\npush!(hdu, key2 => (val2, com2)) # add a second header keyword with a comment\n...                              # add other header keywords\nwrite(hdu, col1 => arr1)         # write a first column\nwrite(hdu, col2 => arr2)         # write a second column\n...                              # write other columns","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where key1 => val1, key2 => (val2,com2), etc. specify header cards, while col1 => arr1, col2 => arr2, etc. specify columns names and associated data. Such a table may be created in a single call:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"write(file,\n      [key1 => val1, key2 => (val2, com2), ...],\n      [col1 => arr1, col2 => arr2, ...])","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"which follows the write(dest, header, data) convention in EasyFITS with dest the destination, header the header, and data the data.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The header may be specified in any forms accepted by the EasyFITS methods. Similarly, the columns may be specified in various forms as explained below.","category":"page"},{"location":"tables/#Writing-table-columns","page":"FITS Table extensions","title":"Writing table columns","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"To write a single column into the FITS table extension hdu:","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"write(hdu, col => arr, ...; first=hdu.first_row, case=false, null=nothing) -> hdu","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"where col is the column name/number and arr is an array of column values. Column values are converted as needed and are written starting at the row specified by first. The leading dimensions of arr should be the same as those specified by the corresponding TDIMn keyword (with n the column number) and the remaining last dimension, if any, corresponds to the row index of the table.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"If col is a column name, keyword case may be used to indicate whether case of letters matters (default is false).","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Keyword null may be used to specify the value of undefined elements in arr.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Any number of columns may be specified as subsequent arguments. The same keywords apply to all columns.","category":"page"},{"location":"tables/#Table-HDU-Properties","page":"FITS Table extensions","title":"Table HDU Properties","text":"","category":"section"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"The following table lists all properties of a FITS table HDU.","category":"page"},{"location":"tables/","page":"FITS Table extensions","title":"FITS Table extensions","text":"Property Description\nnrows Number of rows\nncols Number of columns\ncolumn_names Column names\nfirst_row Index of first row\nlast_row Index of last row\nfirst_column Index of first column\nlast_column Index of last column\ndata_size Table dimensions\ndata_ndims Number of table dimensions\ndata_axes Indices along table dimensions\nextname Extension name\nhduname HDU name\nfile Associated FITS file\nnum HDU number\ntype HDU type: FITS_BINARY_TABLE_HDU\nxtension Extension: \"BINTABLE\" or \"TABLE\"","category":"page"},{"location":"library/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/#FITS-Tables-Extensions","page":"Reference","title":"FITS Tables Extensions","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"names(::FitsTableHDU)\nread(::FitsTableHDU, ::Column)\nread(::Type{Dict}, ::FitsTableHDU, ::Columns, ::Rows)\nread(::Type{Vector}, ::FitsTableHDU, ::Columns, ::Rows)\nread!(::DenseArray, ::FitsTableHDU, ::ColumnName)\nread!(::AbstractDict, ::FitsTableHDU, ::Columns, ::Rows)\nmerge!(::AbstractDict{String,<:Array}, ::FitsTableHDU, ::Columns, ::Rows)\npush!(::AbstractVector{<:AbstractArray}, ::FitsTableHDU, ::Columns, ::Rows)\nwrite(::FitsFile, ::Type{FitsTableHDU}, ::Pair{<:ColumnName,<:Any}..)\nwrite(::FitsTableHDU, ::ColumnDataPair)\nwrite(f::FitsFile, ::Union{Nothing,Header}, ::TableData)","category":"page"},{"location":"library/#Base.names-Tuple{FitsTableHDU}","page":"Reference","title":"Base.names","text":"names(hdu::FitsTableHDU)\nhdu.column_names\n\nyield a vector of the column names of the FITS table extension in hdu.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read-Tuple{FitsTableHDU, Union{AbstractString, Integer, Symbol}}","page":"Reference","title":"Base.read","text":"read(io::IO, T)\n\nRead a single value of type T from io, in canonical binary representation.\n\nNote that Julia does not convert the endianness for you. Use ntoh or ltoh for this purpose.\n\nread(io::IO, String)\n\nRead the entirety of io, as a String (see also readchomp).\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization\"\n\n\n\n\n\nread([R=Array,] hdu::FitsTableHDU, col[, rows]; kwds...) -> vals::R\n\nreads column col of the FITS table extension in hdu and returns its values and, possibly, its units.\n\nThe column col may be specified by its name or by its number. If col is a string or a symbol, keyword case specifies whether uppercase/lowercase matters (case = false by default).\n\nOptional leading argument R is to specify the type of the result which can be an array type, to only retrieve the column values, or a tuple of array and string types, to retrieve the column values and their units.\n\nOptional argument rows is to specify which rows to read. It can be an integer to read a single row, a unit range of integers to read these rows, or a colon : to read all rows (the default). Properties hdu.first_row and hdu.last_row can be used to retrieve the first and last row numbers.\n\nSee read!(::DenseArray,::FitsTableHDU,::ColumName) for the other possible keywords.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read-Tuple{Type{Dict}, FitsTableHDU, Union{Colon, AbstractString, Integer, Symbol, Tuple{Vararg{Integer, N} where N}, Tuple{Vararg{Union{AbstractString, Symbol}, N} where N}, AbstractVector{var\"#s13245\"} where var\"#s13245\"<:Union{AbstractString, Integer, Symbol}}, Union{Colon, Integer, AbstractUnitRange{var\"#s13245\"} where var\"#s13245\"<:Integer}}","page":"Reference","title":"Base.read","text":"read([Dict,] hdu::FitsTableHDU[, cols[, rows]]) -> dict\n\nreads some columns of the FITS table extension in hdu as a dictionary indexed by the column names. The columns to read can be specified by cols which may be a single column name/index, a tuple/range/vector of column names/numbers, or a colon : to read all columns (the default). Column names may be strings or symbols (not a mixture of these). The rows to read can be specified by rows as a single row index, a unit range of row numbers, or a colon : to read all rows (the default).\n\nKeyword rename is to specify a function to change column names. If unspecified, the colmun names are left unchanged if keyword case is true and converted to uppercase letters otherwise.\n\nKeyword units can be used to indicate whether to retrieve the units of the columns. If units is String, the values of the dictionary will be 2-tuples (data,units) with data the column data and units the column units as a string. Otherwise, if units is nothing (the default), the values of the dictionary will just be the columns data.\n\nTo avoid the units keyword, the following methods are provided:\n\nread(Dict{String,Array},               hdu[, cols[, rows]])\nread(Dict{String,Tuple{Array,String}}, hdu[, cols[, rows]])\n\nto yield the same result as read(hdu,...) with respectively units=nothing and units=String.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read-Tuple{Type{Vector{T} where T}, FitsTableHDU, Union{Colon, AbstractString, Integer, Symbol, Tuple{Vararg{Integer, N} where N}, Tuple{Vararg{Union{AbstractString, Symbol}, N} where N}, AbstractVector{var\"#s13245\"} where var\"#s13245\"<:Union{AbstractString, Integer, Symbol}}, Union{Colon, Integer, AbstractUnitRange{var\"#s13245\"} where var\"#s13245\"<:Integer}}","page":"Reference","title":"Base.read","text":"read(Vector, hdu::FitsTableHDU[, cols[, rows]]) -> vec::Vector\n\nreads some columns of the FITS table extension in hdu as a vector. The columns to read can be specified by cols which may be a single column name/index, a tuple/range/vector of column names/numbers, or a colon : to read all columns (the default). Column names may be strings or symbols (not a mixture of these). The rows to read can be specified by rows as a single row index, a unit range of row numbers, or a colon : to read all rows (the default). V is the type of the result.\n\nKeyword units can be used to indicate whether to retrieve the units of the columns. If units is String, the values of the dictionary will be 2-tuples (data,units) with data the column data and units the column units as a string. Otherwise, if units=nothing (the default), the values of the dictionary will just be the columns data.\n\nTo avoid the units keyword and allow more control on the type of the result, the following 2 methods are provided:\n\nread(Vector{<:Array},               hdu[, cols[, rows]])\nread(Vector{Tuple{<:Array,String}}, hdu[, cols[, rows]])\n\nto yield the same result as read(hdu,...) with respectively units=nothing and units=String.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read!-Tuple{DenseArray, FitsTableHDU, Union{AbstractString, Symbol}}","page":"Reference","title":"Base.read!","text":"read!(arr::DenseArray, hdu::FitsTableHDU, col) -> arr\n\noverwrites the elements of array arr with values of the column col of the FITS table extension in hdu and returns arr.\n\nThe column col may be specified by its name or by its number. If col is a string or a symbol, keyword case indicates whether uppercase/lowercase matters (case = false by default).\n\nKeyword first may be specified with the index of the first row to read. By default, first = hdu.first_row and reading starts at the first row of the table.\n\nKeyword anynull may be specified with a reference to a boolean (Ref{Bool}()) to retrieve whether any of the read values is undefined.\n\nKeyword null may be specified with a reference to a value of the same type as the elements of the destination arr (Ref{eltype(arr)}()) to retrieve the value of undefined values. Keyword null may also be set with an array of Bool of same size as arr and which will be set to true for undefined values and to false elsewhere.\n\nOutput arrays arr and null must have contiguous elements, in other words, they must be dense arrays.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read!-Tuple{AbstractDict, FitsTableHDU, Union{Colon, AbstractString, Integer, Symbol, Tuple{Vararg{Integer, N} where N}, Tuple{Vararg{Union{AbstractString, Symbol}, N} where N}, AbstractVector{var\"#s13245\"} where var\"#s13245\"<:Union{AbstractString, Integer, Symbol}}, Union{Colon, Integer, AbstractUnitRange{var\"#s13245\"} where var\"#s13245\"<:Integer}}","page":"Reference","title":"Base.read!","text":"read!(dict, hdu::FitsTableHDU[, cols[, rows]]) -> dict\n\noverwrites the contents of the dictionary dict with the colum(s) cols read from the FITS table extension in hdu and returns the dictionary. Any previous contents is erased, call merge!(dict,hdu,...) to preserve contents.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.merge!-Tuple{AbstractDict{String, var\"#s1\"} where var\"#s1\"<:Array, FitsTableHDU, Union{Colon, AbstractString, Integer, Symbol, Tuple{Vararg{Integer, N} where N}, Tuple{Vararg{Union{AbstractString, Symbol}, N} where N}, AbstractVector{var\"#s13245\"} where var\"#s13245\"<:Union{AbstractString, Integer, Symbol}}, Union{Colon, Integer, AbstractUnitRange{var\"#s13245\"} where var\"#s13245\"<:Integer}}","page":"Reference","title":"Base.merge!","text":"merge!(dict, hdu::FitsTableHDU[, cols[, rows]]) -> dict\n\nmerges the contents of the dictionary dict with the colum(s) cols read from the FITS table extension in hdu and returns the dictionary.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.push!-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:AbstractArray, FitsTableHDU, Union{Colon, AbstractString, Integer, Symbol, Tuple{Vararg{Integer, N} where N}, Tuple{Vararg{Union{AbstractString, Symbol}, N} where N}, AbstractVector{var\"#s13245\"} where var\"#s13245\"<:Union{AbstractString, Integer, Symbol}}, Union{Colon, Integer, AbstractUnitRange{var\"#s13245\"} where var\"#s13245\"<:Integer}}","page":"Reference","title":"Base.push!","text":"push!(vec, hdu::FitsTableHDU[, cols[, rows]]) -> vec\n\nappends rows rows of columns cols read from FITS table extension hdu to the vector vec and returns it.\n\n\n\n\n\n","category":"method"},{"location":"library/#FITS-Image-Extensions","page":"Reference","title":"FITS Image Extensions","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"read(::FitsImageHDU)\nread!(::DenseArray{<:Number}, ::FitsImageHDU, ::SubArrayIndex...)\nread!(::DenseArray, ::FitsImageHDU)\nwrite(::FitsFile, ::Type{FitsImageHDU{T}}, ::NTuple{N,Integer}) where {T,N}\nwrite(::FitsFile, ::Union{Header,Nothing}, ::AbstractArray{T,N}) where {T<:Number,N}\nwrite(::FitsImageHDU{<:Any,N}, ::AbstractArray{T,L}) where {T<:Number,L,N}","category":"page"},{"location":"library/#Base.read-Tuple{FitsImageHDU}","page":"Reference","title":"Base.read","text":"read(R::Type = Array, hdu::FitsImageHDU) -> arr::R\n\nreads the FITS image extension in hdu. Optional argument R is to restrict the ouput type and improve type-stability. For example:\n\narr = convert(Array{Float32}, read(hdu))\narr = read(Array{Float32}, hdu)\narr = read(Array{Float32,2}, hdu)\n\nyield similar results if hdu is a 2-D image extension but the 2nd example is more efficient than the 1st one as no temporary array is needed if the pixel type is not equivalent to Float32 and the 3rd example is completely type-stable.\n\nKeywords anynull and null may be specified to deal with undefined pixel values (see documentation for read!(::DenseArray{<:Number},::FitsImageHDU,::SubArrayIndex...)).\n\n\n\n\n\nread(R::Type = Array, hdu::FitsImageHDU, inds...) -> arr::R\n\nreads a rectangular sub-region of the FITS image extension in hdu defined by the indices inds.... Keywords anynull and null may be specified to deal with undefined pixel values (see documentation for read!(::DenseArray{<:Number},::FitsImageHDU,::SubArrayIndex...)).\n\nThe result is similar to:\n\narr = read(R, hdu)[inds...]\n\nbut is generally more efficient as no array other than the result is allocated and fewer values are read.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.read!-Tuple{DenseArray{var\"#s1\", N} where {var\"#s1\"<:Number, N}, FitsImageHDU, Vararg{Union{Colon, Integer, OrdinalRange{var\"#s13244\", var\"#s13243\"} where {var\"#s13244\"<:Integer, var\"#s13243\"<:Integer}}, N} where N}","page":"Reference","title":"Base.read!","text":"read!(arr::DenseArray{<:Number}, hdu::FitsImageHDU, inds...) -> arr\n\noverwrites arr with a rectangular sub-region of the FITS image extension in hdu defined by the indices inds.... The destination array must have the same dimensions as the rectangular sub-region to read (the same rules as for sub-indexing an array are applied to determine the dimensions of the sub-region). Keywords anynull and null may be specified to deal with undefined pixel values.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.write-Union{Tuple{N}, Tuple{T}, Tuple{FitsFile, Type{FitsImageHDU{T, N} where N}, Tuple{Vararg{Integer, N}}}} where {T, N}","page":"Reference","title":"Base.write","text":"write(file::FitsFile, FitsImageHDU{T}, dims...=()) -> hdu\nwrite(file::FitsFile, FitsImageHDU, T::Type=UInt8, dims...=()) -> hdu\nwrite(file::FitsFile, FitsImageHDU, bitpix::Integer, dims=()) -> hdu\n\ncreate a new primary array or image extension in FITS file file with a specified pixel type T and size dims.... If the FITS file is currently empty then a primary array is created, otherwise a new image extension is appended to the file. Pixel type can be specified as a numeric type T or as an integer BITPIX code bitpix.\n\nAn object to manage the new extension is returned which can be used to push header cards and then to write the data.\n\nFor example:\n\nhdu = write(file, FitsImageHDU, eltype(arr), size(arr))\nhdu[\"KEY1\"] = val1             # add a 1st header record\nhdu[\"KEY2\"] = (val2, str2)     # add a 2nd header record\nhdu[\"KEY3\"] = (nothing, str3)  # add a 3rd header record\nwrite(hdu, arr)                # write data\n\nwill create a new Header Data Unit (HDU) storing array arr with 3 additional header records: one named \"KEY1\" with value val1 and no comments, another named \"KEY2\" with value val2 and comment string str2, and yet another one named \"KEY3\" with no value and with comment string str3. Note that special names \"COMMENT\", \"HISTORY\", and \"\" indicating commentary entries have no associated, only a comment string, say str which can be specified as str or as (,str).\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.write-Union{Tuple{N}, Tuple{T}, Tuple{FitsFile, Union{Nothing, FitsHeader, AbstractVector{var\"#s13243\"} where {K<:Union{AbstractString, Symbol}, var\"#s13243\"<:(Pair{K, var\"#s13244\"} where var\"#s13244\")}, NamedTuple}, AbstractArray{T, N}}} where {T<:Number, N}","page":"Reference","title":"Base.write","text":"write(file::FitsFile, hdr, arr::AbstractArray) -> file\n\nwrites a new FITS Image Extension in file with non-structural header keywords specified by hdr and data specified by array arr.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.write-Union{Tuple{N}, Tuple{L}, Tuple{T}, Tuple{FitsImageHDU{var\"#s1\", N} where var\"#s1\", AbstractArray{T, L}}} where {T<:Number, L, N}","page":"Reference","title":"Base.write","text":"write(hdu::FitsImageHDU, arr::AbstractArray{<:Number}) -> hdu\n\nwrites all the elements of the array arr to the pixels of the FITS image extension of the header data unit hdu. The element of arr are converted to the type of the pixels. The default is to write the complete image pixels, so the size of the destination arr must be identical to the dimensions of the FITS image extension. This behavior may be changed by specifying another value than nothing for the keywords first and/or last:\n\nTo write a rectangular sub-image, specify keywords first and last with the coordinates of the first and last pixels to write as an N-tuple of integers, with N the number of dimensions of the FITS image extension.\nTo write consecutive pixels, specify at least one of the keywords first and/or last with the index of the first and/or last pixels to write as an integer.\n\nWhen at least one of the keywords first and/or last is not nothing, the dimensions of arr are not considered. In any case, the number of elements of arr must be equal to the number of pixels to write.\n\nUnless writing a rectangular sub-image, keyword null may be used to specify the value of undefined elements in arr. For integer FITS images, the FITS null value is defined by the BLANK keyword (an error is returned if the BLANK keyword doesn't exist). For floating point FITS images the special IEEE NaN (Not-a-Number) value will be written into the FITS file.\n\n\n\n\n\n","category":"method"},{"location":"devel/#Notes-for-developers","page":"Notes for developers","title":"Notes for developers","text":"","category":"section"},{"location":"devel/#The-FITS-standard","page":"Notes for developers","title":"The FITS standard","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The FITS format is described in the FITS Standard Document.","category":"page"},{"location":"devel/#The-CFITSIO-sub-module","page":"Notes for developers","title":"The CFITSIO sub-module","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS makes use of the Clang Julia package to automatically build file deps/deps.jl with constants, types, and low level functions to call the functions of the CFITSIO library with arguments of the correct type. All these are available in the EasyFITS.CFITSIO sub-module.","category":"page"},{"location":"devel/#Calls-to-functions-in-the-CFITSIO-library","page":"Notes for developers","title":"Calls to functions in the CFITSIO library","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"When calling functions of the CFITSIO library, there are several things to take care of:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Passing correct arguments. This is partially ensured by the type assertions in the @ccall macro. It is also necessary to check whether a pointer to some opaque structure in the library is valid.\nPreserving objects from being destroyed while being in use. Of course, this is automatically done by Julia for Julia objects, but must be handled for references or pointers to objects provided by the CFITSIO library.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"When an object obj is specified for an argument of type Ptr{T} to be passed to a C function, Julia ccall does something like:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"ref = Base.cconvert(Ptr{T}, obj)\nptr = Base.unsafe_convert(Ptr{T}, ref)\nresult = GC.@preserve ref call_some_c_function(..., ptr, ...)","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Here ref is an object (by default, Base.cconvert(Ptr{T},obj) yields obj itself) to be used with Base.unsafe_convert(Ptr{T},ref) to get the pointer and to be preserved from being garbage collected in order to warrant that the pointer remains valid.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Thanks to this mechanism, it is quite simple to ensure that valid pointers to opaque structures of the CFITSIO library be passed a function of this library. For example, the code below is how is handled a pointer to a fitsfile C structure in our code:","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"isnull(ptr::Ptr{T}) where {T} = ptr === Ptr{T}(0)\ncheck(ptr::Ptr) = isnull(ptr) ? error(\"invalid NULL pointer\") : ptr\nget_handle(file::FitsFile) = getfield(obj, :handle)\nget_file(hdu::AbstractHDU) = getfield(hdu, :file)\nBase.unsafe_convert(Ptr{CFITSIO.fitsfile}, obj::FitsFile) = check(get_handle(obj))\nBase.cconvert(Ptr{CFITSIO.fitsfile}, hdu::AbstractHDU) = get_file(hdu)","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Private methods isnull and check are introduced for readability. Private methods get_handle and get_file are two of the private accessors introduced to hide the fields of a FITS file object and let some other public properties be implemented. The former yields the pointer to the fitsfile C structure that is managed by a FitsFile object, while the latter yields the FitsFile object storing the HDU as it is the one that must be used and preserved when calling a C function requiring a pointer to a fitsfile C structure.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Note that FitsFile objects have a finalizer that automatically releases resources such as the associated fitsfile C structure when the object is garbage collected.","category":"page"},{"location":"devel/#Helper-functions","page":"Notes for developers","title":"Helper functions","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following non-exported functions are provided for meta-programming and for dealing with the types of arguments in calls to the functions of the CFITSIO library.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS.cfunc\nEasyFITS.ctype\nEasyFITS.cpointer\nEasyFITS.get_field_name","category":"page"},{"location":"devel/#EasyFITS.cfunc","page":"Notes for developers","title":"EasyFITS.cfunc","text":"EasyFITS.cfunc(pfx::Union{AbstractString,Symbol}, T::Type) -> sym\n\nyields the symbolic name of the function in the CFITSIO library whose prefix is pfx and whose suffix is deduced from the type T. Long/short function names are supported and automatically detected depending on whether pfx ends with an underscore character.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.ctype","page":"Notes for developers","title":"EasyFITS.ctype","text":"EasyFITS.ctype(T) -> T′\n\nyields the C type equivalent to T in CFITSIO library. This is mostly for Booleans which are treated as C char in the library, the other basic numerical types being unchanged. An error is thrown if the returned type has a different size than that of T. This is to make sure that Julia arrays with elements of type T can safely be used to store values of type T′.\n\nwarning: Warning\nThis only applies to element type of arrays. For boolean scalars, a Cint is the correct type.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.cpointer","page":"Notes for developers","title":"EasyFITS.cpointer","text":"EasyFITS.cpointer(arr::AbstractArray) -> ptr::Ptr{ctype(eltype(arr))}\n\nyields a pointer to the elements of array arr that can be used in calls to functions of the CFITSIO library. Compared to Ptr{Cvoid}(pointer(arr)), this function yields a typed pointer which prevents using arguments of the wrong type.\n\nwarning: Warning\nDo not forget to use GC.@protect arr ... to avoid arr being garbage collected while its address is in use.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Pixel-types","page":"Notes for developers","title":"Pixel types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists conventions used by CFITSIO for pixel types, that is the BITPIX keyword in FITS image extensions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type BITPIX\nBYTE_IMG UInt8 8\nSBYTE_IMG Int8 \nSHORT_IMG Int16 16\nUSHORT_IMG UInt16 \nLONG_IMG Int32 32\nULONG_IMG UInt32 \nLONGLONG_IMG Int64 64\nULONGLONG_IMG UInt64 \nFLOAT_IMG Float32 -32\nDOUBLE_IMG Float64 -64","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Types without a value in the BITPIX column are converted by the CFITSIO library into the other signed/unsigned type using special values of the BSCALE and BZERO keywords to allow for the reciprocal conversion. This is explicitly allowed by the FITS Standard (version 4.0).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS.type_to_bitpix\nEasyFITS.type_from_bitpix","category":"page"},{"location":"devel/#EasyFITS.type_to_bitpix","page":"Notes for developers","title":"EasyFITS.type_to_bitpix","text":"EasyFITS.type_to_bitpix(T)\n\nyields the code for FITS image pixels of type T. Argument can also be an array instance or type.\n\nBasic numeric types are recognized by this method which may be extended by other packages to yield the CFITSIO codes equivalent to their own types. The CFITSIO constants (to be prefixed by EasyFITS.CFITSIO.) and their corresponding Julia types and standard BITPIX code are:\n\nCFITSIO Constant Julia Type BITPIX\nBYTE_IMG UInt8 8\nSBYTE_IMG Int8 \nSHORT_IMG Int16 16\nUSHORT_IMG UInt16 \nLONG_IMG Int32 32\nULONG_IMG UInt32 \nLONGLONG_IMG Int64 64\nULONGLONG_IMG UInt64 \nFLOAT_IMG Float32 -32\nDOUBLE_IMG Float64 -64\n\nNote that CFITSIO can read/write non-standard pixel types (those without a BITPIX value above) by setting keywords BSCALE and BZERO with special values as explicitely allowed by the FITS Standard (version 4).\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_bitpix","page":"Notes for developers","title":"EasyFITS.type_from_bitpix","text":"EasyFITS.type_from_bitpix(b) -> T\n\nyields the Julia type T corresponding to FITS \"BITPIX\" b.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Array-data-types","page":"Notes for developers","title":"Array data types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists conventions used by CFITSIO for array element types.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code C Type Short Suffix Long Suffix\nTLOGICAL char l _log\nTBYTE unsigned char b _byt\nTSBYTE signed char sb _sbyt\nTUSHORT unsigned short ui _usht\nTSHORT short i _sht\nTUINT unsigned int uk _uint\nTINT int k _int\nTULONG unsigned long uj _ulng\nTLONG long j _lng\nTULONGLONG unsigned long long ujj _ulnglng\nTLONGLONG long long jj _lnglng\nTFLOAT float e _flt\nTDOUBLE double d _dbl\nTCOMPLEX float complex c _cmp\nTDBLCOMPLEX double complex m _dblcmp\nTSTRING char* s _str\nTBIT  x _bit\n  u _null","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Complex types float complex and double complex are stored are pairs of single/double precision floating-point values (this is not guaranteed by C99 standard so strict equivalence does not hold here).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS.type_to_code\nEasyFITS.type_from_code","category":"page"},{"location":"devel/#EasyFITS.type_to_code","page":"Notes for developers","title":"EasyFITS.type_to_code","text":"EasyFITS.type_to_code(T)\n\nyields the CFITSIO type code for a keyword value or table cells of type T. Argument can also be an array instance or type.\n\nBasic numeric types and string types are recognized by this method which may be extended by other packages to yield the CFITSIO codes equivalent to their own types. The CFITSIO type constants (to be prefixed by EasyFITS.CFITSIO.) and their corresponding C and Julia types are:\n\nCFITSIO Constant C Types Julia Types\nTLOGICAL char Cchar, Bool\nTBYTE unsigned char UInt8, Bool\nTSBYTE signed char Int8\nTUSHORT unsigned short Cushort\nTSHORT short Cshort\nTUINT unsigned int Cuint\nTINT int Cint\nTULONG unsigned long Culong\nTLONG long Clong\nTULONGLONG unsigned long long Culonglong\nTLONGLONG long long Clonglong\nTFLOAT float Cfloat\nTDOUBLE double Cdouble\nTCOMPLEX float complex Complex{Cfloat}\nTDBLCOMPLEX double complex Complex{Cdouble}\nTSTRING char* \nTBIT  \n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_code","page":"Notes for developers","title":"EasyFITS.type_from_code","text":"EasyFITS.type_from_code(c) -> T\n\nyields the Julia type T corresponding to CFITSIO type code c.\n\n\n\n\n\n","category":"function"},{"location":"devel/#Column-data-types","page":"Notes for developers","title":"Column data types","text":"","category":"section"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The following table lists the correspondences between the TFORMn letter in FITS table extensions and the column data type.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type TFORM Description\nTLOGICAL Bool ’L’ Logical (1 byte)\nTBIT  ’X’ Bit (special)\nTBYTE UInt8 ’B’ 8-bit unsigned integer\nTSHORT Int16 ’I’ 16-bit signed integer\nTLONG Int32 ’J’ 32-bit signed integer\nTLONGLONG Int64 ’K’ 64-bit signed integer\nTSTRING String ’A’ Character (1 byte, used for strings)\nTFLOAT Float32 ’E’ 32-bit floating point\nTDOUBLE Float64 ’D’ 64-bit floating point\nTCOMPLEX ComplexF32 ’C’ 64-bit complex\nTDBLCOMPLEX ComplexF64 ’M’ 128-bit complex\n  ’P’ 32-bit array descriptor\n  ’Q’ 64-bit array descriptor","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"A few non-standard TFORM letters are allowed by CFITSIO. These are converted by the library into other types using TSCALE and TZERO keywords to allow for the reciprocal conversion following the same principles as for the BITPIX code and the BSCALE and BZERO keywords.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"Type Code Julia Type TFORM Description\nTSBYTE Int8 ’S’ 8-bit signed integer\nTUSHORT UInt16 ’U’ 16-bit unsigned integer\nTULONG UInt32 ’V’ 32-bit unsigned integer\nTULONGLONG UInt64 ’W’ 64-bit unsigned integer","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The Type Code column indicates the code used by CFITSIO (it is not always consistent with the C types as defined in the above table, so my guess is that this code is only used to keep track of the column data type internally).","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"The above equivalence rules are implemented by the following two non-exported functions.","category":"page"},{"location":"devel/","page":"Notes for developers","title":"Notes for developers","text":"EasyFITS.type_to_letter\nEasyFITS.type_from_letter","category":"page"},{"location":"devel/#EasyFITS.type_to_letter","page":"Notes for developers","title":"EasyFITS.type_to_letter","text":"EasyFITS.type_to_letter(T)\n\nyields the letter of the TFORMn keyword representing table cells of type T in FITS. Argument can also be an array instance or type.\n\n\n\n\n\n","category":"function"},{"location":"devel/#EasyFITS.type_from_letter","page":"Notes for developers","title":"EasyFITS.type_from_letter","text":"EasyFITS.type_from_letter(c) -> T\n\nyields the Julia type T corresponding to CFITSIO column type letter c as assumed for the TFORMn keywords.\n\n\n\n\n\n","category":"function"},{"location":"images/#FITS-image-extensions","page":"FITS image extensions","title":"FITS image extensions","text":"","category":"section"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"FITS image extensions store multi-dimensional arrays with numerical values exactly as regular Julia arrays. In EasyFITS, a FITS image extension in an open file is represented by an object of type FitsImageDHU{T,N} with T the element type and N the number of dimensions.","category":"page"},{"location":"images/#Image-HDU-properties","page":"FITS image extensions","title":"Image HDU properties","text":"","category":"section"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"An image HDU has the following properties:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"Property Description\ndata_size Array dimensions\ndata_ndims Number of dimensions N\ndata_eltype Element type T\nextname Extension name\nhduname HDU name\nfile Associated i/o FITS file\nnumber HDU number\ntype HDU type FITS_IMAGE_HDU\nxtension Extension, i.e. \"IMAGE\"","category":"page"},{"location":"images/#Reading-a-FITS-image","page":"FITS image extensions","title":"Reading a FITS image","text":"","category":"section"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"To read the data stored by the Header Data Unit (HDU) object hdu of type FitsImageDHU HDU as an array arr, call read as:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(hdu)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"The result is of type Array{T,N} if hdu isa FitsImageDHU{T,N} holds. To choose another element type, say, S, just do:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(Array{S}, hdu)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"This is similar but more efficient than any of:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = S.(read(hdu))\narr = convert(Array{S}, read(hdu))","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"For type-stability, the expected number of dimension, say N, may also be specified. For example, any of:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(Array{Float32,2}, hdu)\narr = read(Matrix{Float32}, hdu)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"ensure that arr will be a 2-dimensional image with pixels of type Float32.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"Call read! to overwrite the elements of an existing array with the contents of the FITS image extension. For example:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"read!(arr, hdu)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"An hyper-rectangular sub-image can be read using the same syntax as for a Julia view by specifying indices and/or index ranges after the hdu argument. Index ranges may have non-unit steps but steps must all be positive. For example:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(hdu, :, :, 2)","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"yields the 2nd slice in a 3-dimensional FITS image.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"The result is similar to:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"arr = read(R, hdu)[:,:,2]","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"but should be more efficient as no array other than the result is allocated and fewer values are read.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"Call read! instead of read to overwrite the contents of an existing array. Following the previous example, reading the next slice could be done by:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"read!(arr, hdu, :, :, 3)","category":"page"},{"location":"images/#Creating-an-image-extension","page":"FITS image extensions","title":"Creating an image extension","text":"","category":"section"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"To create a new FITS image extension in an open FITS file","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"write(file::FitsFile, FitsImageHDU{T}, dims...=()) -> hdu\nwrite(file::FitsFile, FitsImageHDU, T::Type=UInt8, dims...=()) -> hdu\nwrite(file::FitsFile, FitsImageHDU, bitpix::Integer, dims=()) -> hdu","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"create a new primary array or image extension in FITS file file with a specified pixel type T and size dims.... If the FITS file is currently empty then a primary array is created, otherwise a new image extension is appended to the file. Pixel type can be specified as a numeric type T or as an integer BITPIX code bitpix.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"An object to manage the new extension is returned which can be used to push header cards and then to write the data.","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"For example:","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"hdu = write(file, FitsImageHDU, eltype(arr), size(arr))\nhdu[\"KEY1\"] = val1             # add a 1st header record\nhdu[\"KEY2\"] = (val2, str2)     # add a 2nd header record\nhdu[\"KEY3\"] = (nothing, str3)  # add a 3rd header record\nwrite(hdu, arr)                # write data","category":"page"},{"location":"images/","page":"FITS image extensions","title":"FITS image extensions","text":"will create a new Header Data Unit (HDU) storing array arr with 3 additional header records: one named \"KEY1\" with value val1 and no comments, another named \"KEY2\" with value val2 and comment string str2, and yet another one named \"KEY3\" with no value and with comment string str3. Note that special names \"COMMENT\", \"HISTORY\", and \"\" indicating commentary entries have no associated, only a comment string, say str which can be specified as str or as (,str).","category":"page"},{"location":"files/#Access-to-FITS-files","page":"Access to FITS files","title":"Access to FITS files","text":"","category":"section"},{"location":"files/#Direct-reading-of-data","page":"Access to FITS files","title":"Direct reading of data","text":"","category":"section"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"The simplest way to read some data in a FITS file is to call readfits:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"data = readfits(filename, args...; kwds...)","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"with filename the name of the file.","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"By default, the data of the first FITS extension in filename is read. Keyword ext may however be set with a number, a name, or a symbol to select another extension. Another possibility is to specify the keyword extended = true to open the file using the extended file name syntax implemented by the CFITSIO library.","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"The default is to read all the data part of the selected FITS extension but optional arguments args... and keywords kwds... may be specified to restrict the read contents:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"If the FITS extension is an image, args... specifies the ranges of pixels to read along the dimensions. For example:\ndata = readfits(filename, :, :, 5)\nwould read the 5th slice in a 3-dimensional image. This is equivalent but more efficient than:\ndata = readfits(filename)[:, :, 5]\nwhich amounts to reading all the data and then only keep the 5th slice.\nIf the FITS extension is a table, args... may be up to 2 arguments, cols and rows, to respectively select a subset of columns and rows. For example:\nA = readfits(filename, (\"Speed\", \"Height\"))\nB = readfits(filename, :, 11:40)\nrespectively yield the columns named Speed and Height of the table and all the columns of the table but only for rows in the range 11:40. Keyword case may be used to indicate whether letter case does matter in the column names. Note that, in EasyFITS the rows of a table correspond to the last dimension of arrays. This is to have the same storage order in memory and in the FITS file. Method permutedims can be used is this convention does not suit you.","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"The type of the object returned by readfits depends on the kind of the FITS extension and may also depend on the optional arguments args... and on the keywords kwds...:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"If the FITS extension is an image, the data is read as a Julia Array.\nIf the FITS extension is a table, then, if cols is a single column name or number, an array of the columns values is returned, otherwise, a dictionary indexed by the column names is returned. Note that, a column range like 4:4 would yield a dictionary with a single column (the 4th one) in that context. Keywords case and rename are available to indicate how to search the columns by name in the table and how to translate these names into dictionary keys.","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"To avoid ambiguities or for improved type-stability, a leading type argument can be specified in readfits to indicate the expected type for the returned data:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"data = readfits(R::Type, filename, args...; kwds...)::R","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"Array type parameters such as element type and number of dimensions may be specified in R. For example:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"data = readfits(Array{Float32,3}, filename)","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"ensures that the result be a single precision floating-point 3-dimensional array; while:","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"data = readfits(Dict, filename, cols; ext=2)","category":"page"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"ensures that the table in 2nd FITS Header Data Unit is returned as a dictionary even though cols specifies a single column.","category":"page"},{"location":"files/#Direct-writing-of-data","page":"Access to FITS files","title":"Direct writing of data","text":"","category":"section"},{"location":"files/","page":"Access to FITS files","title":"Access to FITS files","text":"In principle, directly writing data in a FITS file is as simple as direct reading of data.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The EasyFITS package provides an interface for reading/writing FITS files (widely used in Astronomy) in [Julia][julia-url].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code is on GitHub.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"files.md\", \"hdus.md\", \"headers.md\", \"images.md\",\n         \"tables.md\", \"install.md\", \"grammar.md\", \"library.md\"]","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"grammar/#The-*Grammar*-of-EasyFITS","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"","category":"section"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"FITS file may have quite complex structure and *easyFITS implement a grammar that is intended to make clear the intention when reading the code and to help to guess the correct syntax when writing code. Most of the assumed rules should be familiar to Julia users.","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"The general syntax to read some data in a FITS file follows the following pattern:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"data = read([datatype,] src[, what...])","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"where:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"datatype is an optional Julia type to specify the expected type of the result.\nsrc is the source to read: a filename name, a FitsFile object representing an open FITS file, or a FitsHDU object representing a FITS Header Data Unit in an open FITS file.\nwhat... denotes optional arguments to specify which part(s) to read: index ranges of an array if reading a FITS image extension, column(s) and rows if reading a FITS table extension.","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"Overwriting the contents of an existing destination object dest may be done by:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"read!(dest, src, what...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"or by:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"merge!(dest, src, what...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"when the intention is to preserve (part of) the contents of dest, or also by:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"push!(dest, src, what...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"to append the read data to the contents of dest.","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"Create a new HDU in file:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"hdu = write(file, hdutype, defs...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"Write some data in a FITS file:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"write(file, header, data) -> file","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"yields file so that chaining calls is possible to write several HDUs in a row:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"write(write(write(file, header1, data1), header2, data2), ...)","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"which is equivalent to the more readable form:","category":"page"},{"location":"grammar/","page":"The Grammar of EasyFITS","title":"The Grammar of EasyFITS","text":"write(file, header1, data1, header2, data2, ...)","category":"page"}]
}
